@using MyProject.Components
@inject HttpClient Http
@inject ILocalStorageService LocalStorage

@*
    Issue: To use this component, must use a reference with @ref. 
    Solution: Figure out how bindings work in reverse.
    Steps: Posted question on Stackoverflow.
*@

<EditForm OnSubmit="@SearchForStudent" Model="username">
    <label>
        Student Username
        <InputText @bind-Value=username/>
    </label>
    <button type="submit">Search</button>
</EditForm>

<h3>Class being made</h3>

@foreach (Student student in Students)
{
    <label>
        @student.Name
        <button @onclick="() => HandleRemoveStudent(student)">Remove</button>
    </label>
}

<hr>

<h3>Search Results</h3>

@foreach (Student student in searchResults)
{
    <label>
        @student.Name
        <button @onclick="() => HandleAddStudent(student)">Add</button>
    </label>
}

@code
{
    [Parameter]
    public ISet<Student> Students { get; set; } = new HashSet<Student>();

    [Parameter]
    public Func<Task> SearchForStudentsFunc { get; set; } = null!; 

    private string username = string.Empty;

    private ISet<Student> searchResults = new HashSet<Student>();

    protected override void OnInitialized()
    {
        SearchForStudentsFunc = SearchForStudent; 

        base.OnInitialized();
    }

    private async Task SearchForStudent()
    {
        if (string.IsNullOrWhiteSpace(username))
        {
            return; 
        }

        searchResults = (await Http.GetFromJsonAsync<HashSet<Student>>($"https://localhost:7053/Student/SoundsLike/{username}") ?? new HashSet<Student>());

        searchResults.ExceptWith(Students);

        StateHasChanged();
    }

    private void HandleAddStudent(Student student)
    {
        Students.Add(student);

        searchResults.Remove(student);

        StateHasChanged();
    }

    private void HandleRemoveStudent(Student student)
    {
        Students.Remove(student);

        StateHasChanged();
    }
}