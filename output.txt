== Client
=== App.razor
```cs
﻿@using Microsoft.AspNetCore.Components;

<Router AppAssembly="@typeof(App).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" />
        <FocusOnNavigate RouteData="@routeData" Selector="h1" />
    </Found>
    <NotFound>
        <PageTitle>Not found</PageTitle>
        <LayoutView Layout="@typeof(MainLayout)">
            <p role="alert">Sorry, there's nothing at this address.</p>
        </LayoutView>
    </NotFound>
</Router>
```
=== bin
==== Debug
===== net7.0
====== de
====== wwwroot
======= _framework
======== de
==== Release
===== net7.0
=== CourseworkPastPaperApplication2.Client.csproj
```cs
<Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly">

  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>disable</ImplicitUsings>
    <ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Blazored.LocalStorage" Version="4.3.0" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="7.0.5" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.DevServer" Version="7.0.5" PrivateAssets="all" />
    <PackageReference Include="Microsoft.Extensions.Caching.Memory" Version="7.0.0" />
    <PackageReference Include="OneOf" Version="3.0.243" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Shared\CourseworkPastPaperApplication2.Shared.csproj" />
  </ItemGroup>

  <ItemGroup>
    <ServiceWorker Include="wwwroot\service-worker.js" PublishedContent="wwwroot\service-worker.published.js" />
  </ItemGroup>

</Project>

```
=== obj
==== Debug
===== net7.0
====== build-gz
====== CourseworkPastPaperApplication2.Client.AssemblyInfo.cs
```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CourseworkPastPaperApplication2.Client")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("CourseworkPastPaperApplication2.Client")]
[assembly: System.Reflection.AssemblyTitleAttribute("CourseworkPastPaperApplication2.Client")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


```
====== CourseworkPastPaperApplication2.Client.GlobalUsings.g.cs
```cs
// <auto-generated/>
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

```
====== ref
====== refint
====== scopedcss
======= bundle
======= projectbundle
======= Shared
====== service-worker
====== staticwebassets
==== Release
===== net7.0
====== CourseworkPastPaperApplication2.Client.AssemblyInfo.cs
```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CourseworkPastPaperApplication2.Client")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("CourseworkPastPaperApplication2.Client")]
[assembly: System.Reflection.AssemblyTitleAttribute("CourseworkPastPaperApplication2.Client")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


```
====== CourseworkPastPaperApplication2.Client.GlobalUsings.g.cs
```cs
// <auto-generated/>
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

```
====== ref
====== refint
====== staticwebassets
=== Pages
==== Add-Assignment.razor
```cs
﻿@*
    Page title, {ClassId:guid} indicates that the page should be provided with an ID for a class when initialised
    Injects an HTTP client via dependency injection. 
    Also injects a local storage service. 
*@
@page "/add-assignment/{ClassId:guid}"
@inject HttpClient Http
@inject ILocalStorageService LocalStorage
@using MyProject.Components
@using OneOf
@using OneOf.Types
@using System.IO;

<PageTitle>Add Assignments</PageTitle>

@*Text input component with its value binded to the assignmentName variable and a placeholder of `Assignment Name`*@
<InputText @bind-Value="assignmentName" placeholder="Assignment Name"/>
<br/>

@*Date input with its value bound to the due variable and a minimum date of minimumDateForDue*@
Due: <InputDate TValue="DateOnly" @bind-Value="due" min="@minimumDateForDue"/>
<br/>
@*Displays the error message if one is present. *@
@errorMessage
<br/>
@*Component that allows for searching for and selecting questions with the HandleQuestionSelected function provided to govern what to do when a question is selected. *@
<SearchForQuestion OnQuestionSelected="HandleQuestionSelected"/>
<br/>

@*
    Displays all retrieved questions with their file names and a button to remove them from the set of questions. 
    This is a custom component found in the Shared directory of the Client project. 
*@
@foreach (var question in questions)
{
    @*@onclick handles when the button is clicked, removes the question from the set of retrieved questions and then indicates that the StateHasChanged and so that the component should rerender*@
    @Path.GetFileNameWithoutExtension(question.FileName) <button @onclick="() => { questions.Remove(question); StateHasChanged(); }">Remove Question</button>
    <br>
}

<br/>

@*Button linking to the AddNewAssignment function that adds a new assignment*@
<button @onclick="AddNewAssignment">Add new Assignment</button>


@code
{
    @*ID parameter the page was provided with. *@
    [Parameter]
    public Guid ClassId { get; set; }

    @*String representation of today in ISO 8601 format. *@
    private readonly string minimumDateForDue = DateOnly.FromDateTime(DateTime.Now).ToString("yyyy-MM-dd");

    @*Questions to add*@
    private HashSet<Question> questions { get; set; } = new HashSet<Question>();

    // Error message in case adding an assignment fails. 
    private string errorMessage = string.Empty;

    // Assignment name for assignment to create. 
    private string assignmentName { get; set; } = string.Empty;

    // Date assignment is due, initialised to today. 
    private DateOnly due { get; set; } = DateOnly.FromDateTime(DateTime.Now);

    // Adds the question to the set of questions to add. 
    private void HandleQuestionSelected(Question question)
    {
        questions.Add(question);
    }

    // Returns a discriminated union of Success and Error from the OneOf package. 
    private async Task<OneOf<Success, Error>> AddNewAssignment()
    {
        // Gets today. 
        var today = DateOnly.FromDateTime(DateTime.Now);

        // If due is before today. 
        if (due.CompareTo(today) == -1)
        {
            errorMessage = "Cannot be due before today";

            // Indicates that the component should rerender and returns an Error. 
            StateHasChanged();

            return new Error();
        }

        Assignment assignment = new Assignment
        {
            Name = assignmentName,
            Due = due,
            Set = today
        };

        // Adds each question to the assignment
        questions.ForEach(assignment.Questions.Add);

        // Uses the injected HttpClient to post the assignment to the server. 
        await Http.PostAsJsonAsync<Assignment>($"https://localhost:7053/Class/{ClassId}/Assignments", assignment);

        // Rerenders the page and indicates a successful execution. 
        StateHasChanged();

        return new Success();
    }
}
```
==== Add-Class.razor
```cs
﻿@*
    Injects an HTTP client via dependency injection.
    Also injects a local storage service.
*@
@page "/add-class"
@inject HttpClient Http
@using MyProject.Components;
@inject ILocalStorageService LocalStorage

<PageTitle>Add Class</PageTitle>

@*Text input component with its value binded to the className variable and a placeholder of `Class Name`*@
<InputText @bind-Value="className" placeholder="Class Name"/>
<br/>
@*
    Custom razor component used for collecting a set of distinct students, can be found in Client/Shared directory. 
    The @ref indicates that a reference to the component should be stored in the addStudentsComponentReference variable, this allows for more manual control over the component without relying on bindings. 
*@
<AddStudents @ref="addStudentsComponentReference"/>

@*A button that, when clicked, will call the AddNewClass method. *@
<button @onclick="AddNewClass">Add new Class</button>


@code
{
    // The reference to the AddStudents component. 
    private AddStudents addStudentsComponentReference = null!;

    // Function used for actually searching for students. 
    private Func<Task> SearchForStudent { get; set; } = null!;

    // Name of the class being created. 
    private string className { get; set; } = string.Empty;

    // Function called when button to add class is clicked. 
    private async Task AddNewClass()
    {
        // Instantiates a task of retrieving the user data from local storage. 
        ValueTask<Teacher> teacher = LocalStorage.GetItemAsync<Teacher>("user");

        // Instantiates a new Class with the Students from the addStudentsComponentReference component and the provided class name. 
        Class _class = new Class { Name = className, Students = addStudentsComponentReference.Students };

        // Awaits the completion of the task two lines above and uses the result to send an HTTP PUT to the server that should create the class and add it to the Teacher's classes. 
        // Also gets the response in case that needs to be worked with in the future. 
        var response = await Http.PutAsJsonAsync<Class>($"https://localhost:7053/Teacher/{(await teacher).Id}/Classes", _class);

        // Clears the students and searches for a new set of students matching previous conditions. 
        addStudentsComponentReference.Students.Clear();

        await addStudentsComponentReference.SearchForStudentsFunc();

        // Indicates for the page to rerender. 
        StateHasChanged();
    }
}
```
==== Add-Students-To-Class.razor
```cs
﻿@*
    Page title, {ClassId:guid} indicates that the page should be provided with an ID for a class when initialised
    Injects an HTTP client via dependency injection.
    Also injects a navigation manager that can reroute the user. 
*@
@page "/add-students-to-class/{ClassId:guid}"
@using MyProject.Components
@inject HttpClient Http
@inject NavigationManager NavManager

<PageTitle>Add Students To Class</PageTitle>

@*
    Ensures the set of students that forms the class being made up is not null and renders the AddStudents component if it is not. 
    The @ref indicates that a reference to the component should be stored in the addStudentsComponentReference variable, this allows for more manual control over the component without relying on bindings.
*@
@if (selectedClass is not null)
{
    <AddStudents @ref="addStudentsComponentReference"/>
}

@*Adds a button that, when clicked, will call the AddStudentsToClass method and add selected students to the class. *@
<button @onclick="AddStudentsToClass">Add Students to Class</button>

@code
{
    @*ID parameter the page was provided with. *@
    [Parameter]
    public Guid ClassId { get; set; }

    // 
    private ISet<Student> selectedClass = null!; 

    private AddStudents addStudentsComponentReference = null!;

    protected override async Task OnInitializedAsync()
    {
        // Gets all students in the class and deserialises them to a HashSet, ensuring no duplicates can exist within the set and so within the class. 
        selectedClass = await Http.GetFromJsonAsync<HashSet<Student>>($"https://localhost:7053/Classs/{ClassId}/Students") ?? Enumerable.Empty<Student>().ToHashSet();

        await base.OnInitializedAsync();
    }

    private async Task AddStudentsToClass()
    {
        // Sends all students save for those already in the class to the server to be added to the class. 
        var response = await Http.PostAsJsonAsync<IEnumerable<Student>>($"https://localhost:7053/Class/{ClassId}/Add", addStudentsComponentReference.Students.Except(selectedClass));

        // Navigates back to the view-classes-assignments page. 
        NavManager.NavigateTo("/view-classes-assignments");
    }
}
```
==== Class-Results.razor
```cs
﻿@*
    Page title, {AssignmentId:guid} indicates that the page should be provided with an ID for an assignment when initialised
    Injects an HTTP client via dependency injection.
    Also injects a navigation manager that can reroute the user. 
    Also injects a local storage service that allows for the page to access local storage. 
*@
@page "/class-results/{AssignmentId:guid}"
@inject HttpClient Http
@inject ILocalStorageService LocalStorage
@inject NavigationManager NavManager
@using System.Text.Json
@using System.Text.Json.Serialization
@using CourseworkPastPaperApplication2.Shared

<PageTitle>View Class Results</PageTitle>

@*
    Ensures that the results table is not null then, if not null, renders the component for displaying the results table. 
    Sets the results for the component to use to be the results retrieved from the server. 
    Sets the OnSaveChanges event callback to be SaveNewResults, this triggers when the user clicks a button to save new results they have added to the component. 
    The ResultsTableComponent is a custom component for rendering results tables and can be found in Client/Shared. 
*@
@if (results is not null)
{
    <ResultsTableComponent Results="results" OnSaveChanges="SaveNewResults"/>
}


@code
{
    @*ID parameter the page was provided with. *@
    [Parameter]
    public Guid AssignmentId { get; set; }

    // ResultsTable, the results being displayed are to represent. 
    private ResultsTable? results { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // Creates new JSON options to use for deserialisation in the page. 
        JsonSerializerOptions jsonOptions = new JsonSerializerOptions
        {
            Converters = { new IgnorePropertyIfConverter<Question>(info => info.Name == "Data") },
            PropertyNameCaseInsensitive = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        // Deserialises the components required to build a results table for the assignment from the server. 
        ResultsTableInitialisationComponents? resultsTableInitialisationComponents = await Http.GetFromJsonAsync<ResultsTableInitialisationComponents>($"https://localhost:7053/Assignment/{AssignmentId}/Results");

        // Ensures that the components were able to be found (null if not found). 
        if (resultsTableInitialisationComponents is null)
        {
            // Indicates an error then returns early. 
            Console.Error.WriteLine($"Assignment with id {AssignmentId} not found");

            return;
        }

        // Gets references to the questions and students for quicker and more readable access. 
        Question[] questions = resultsTableInitialisationComponents.Questions;
        Student[] students = resultsTableInitialisationComponents.Students;

        // Makes separate queries for the students to get their paper results since doing it all in a single query would put unnecessary stress on the server. 
        await students.ForEach(async student => student.PaperResults.AddRange((await Http.GetFromJsonAsync<IEnumerable<PaperResult>>($"/Assignment/{AssignmentId}/Student/{student.Id}/Result") ?? Enumerable.Empty<PaperResult>())));

        // Creates a table and assigns it to results to be used in the ResultsTableComponent component. 
        results = BuildTableFromQuestionsAndStudents(questions, students);

        await base.OnInitializedAsync();
    }

    // Saves the new results by sending all the paper results to the server to be updated. 
    private async Task SaveNewResults(IEnumerable<PaperResult> paperResults)
    {
        await Http.PutAsJsonAsync<IEnumerable<PaperResult>>($"https://localhost:7053/PaperResult/Results", paperResults);
    }

    // Builds a ResultsTable from questions and students. 
    private ResultsTable BuildTableFromQuestionsAndStudents(Question[] questions, Student[] students)
    {
        // Initialises variables used. 
        int rowCount = questions.Length + 1;
        int columnCount = students.Length;
        string[][] scoresTable = new string[rowCount][];

        for (int i = 0; i < scoresTable.Length; i++)
        {
            scoresTable[i] = new string[columnCount];
        }

        // Adds each paper result out of the score for the question in the form {score}/{marks}, for example: 9/15 marks for a question. 
        foreach (var (i, question) in questions.WithIndex())
        {
            // Gets the paper result that matches to the question. 
            foreach (var (j, paperResult) in students.Select(student => student.PaperResults.First(result => result.QuestionId == question.Id)).WithIndex())
            {
                scoresTable[i][j] = $"{paperResult.Score}/{question.Marks}";
            }
        }

        return new ResultsTable(scoresTable, questions, students);
    }
}
```
==== Login.razor
```cs
﻿@page "/"

<PageTitle>Login</PageTitle>

<h1 style="font-family:'Cascadia Code'">Login</h1>

@*
    This uses two instances of a generic component that provide login forms. 
    The first allows the teacher to login and the second allows the student to login. 
*@
<LoginComponent TUser="Teacher"/>
<LoginComponent TUser="Student"/>
```
==== Recovery.razor
```cs
﻿@*This page has not been implemented. *@
@page "/recovery"

<PageTitle>Recovery</PageTitle>
```
==== Sign-Up.razor
```cs
﻿@page "/sign-up"

<PageTitle>Sign Up</PageTitle>

<h1 style="font-family:'Cascadia Code'">Sign Up</h1>

@*
    This uses two instances of a generic component that provide sign up forms.
    The first allows the teacher to sign up and the second allows the student to sign up.
*@
<SignUpComponent TUser="Teacher"/>
<SignUpComponent TUser="Student"/>
```
==== Student-Homepage.razor
```cs
﻿@*This page has not been implemented*@
@page "/student-homepage"
@inject NavigationManager NavManager

<PageTitle>Homepage</PageTitle>
```
==== Teacher-Homepage.razor
```cs
﻿@page "/teacher-homepage"
@inject NavigationManager NavManager

<PageTitle>Homepage</PageTitle>

@*Creates a list of links for the teacher to navigate around the project. *@
<div style="display: grid">
    <NavLink href="/upload-papers">
        Upload Papers
    </NavLink>
    <NavLink href="/view-classes-assignments">
        View Classes/Assignments
    </NavLink>
</div>
```
==== Upload-Papers.razor
```cs
﻿@*Injects an HttpClient into the page to allow it to make HTTP requests. *@
@page "/upload-papers"
@using System.IO;
@inject HttpClient Http

<PageTitle>Upload Papers</PageTitle>

@*Input value of marks, binded to the marks variable. *@
Marks: <InputNumber TValue="int" @bind-Value="marks" Step="1"/>, @marks

<br>

@*File input, set to accept images and OnChange is set to the HandleFileChange function*@
<InputFile accept="image/*" OnChange="HandleFileChange"/>

<br>
@*
    Displays lists of all the radio options: exam board and level. 
    Each set of options is prepended by a null value which is translated to no level or exam board or `None`. 
*@
@if (options is not null)
{
    <InputRadioGroup TValue="Level" @bind-Value="level">
        @foreach (Level? levelOption in options.Levels.Prepend(null))
        {
            <InputRadio Value="levelOption"/> 
            @(levelOption?.Name ?? "None")
        }
    </InputRadioGroup>
    <br>
    <hr>
    <InputRadioGroup TValue="ExamBoard" @bind-Value="examBoard">
        @foreach (ExamBoard? examBoardOption in options.ExamBoards.Prepend(null))
        {
            <InputRadio Value="examBoardOption"/>
            @(examBoardOption?.Name ?? "None")
        }
    </InputRadioGroup>
}

<br>

@*Button that links to the HandleSubmit function. *@
<button @onclick="HandleSubmit">Submit File</button>

@*Renders the image file selected to make the question out of. *@
@if (url is not null)
{
    <img src="@url"/>
}

@code
{
    // Represents the radio options. 
    private RadioOptions? options { get; set; }

    // Represents the selected level and exam board. 
    private Level? level { get; set; }
    private ExamBoard? examBoard { get; set; }

    // Represents the data URL that represents the image. 
    private string? url { get; set; }
    // Represents the count of marks the question is to be worth. 
    private int marks { get; set; } = 1;

    // Actual image file. 
    IBrowserFile? image;
    // Bytes representing the image file. 
    byte[]? imageData; 

    protected override async Task OnInitializedAsync()
    {
        // Retrieves the radio options from the server. 
        options = await Http.GetFromJsonAsync<RadioOptions>("https://localhost:7053/Options") ?? new RadioOptions(ExamBoards: Array.Empty<ExamBoard>(), Levels: Array.Empty<Level>());

        await base.OnInitializedAsync();
    }

    // Handles file changes by translating the image into a data URL and storing the images data for sending to the server later. 
    private async Task HandleFileChange(InputFileChangeEventArgs e)
    {
        // Gets the image from the event arguments. 
        image = e.File;

        /// Could be optimised to avoid unnecessary allocations
        // Manipulates streams to retrieve the byte[] representation of the image then converts that to a data URL and stores the image data as well. 
        using (var reader = new MemoryStream())
        {
            await image.OpenReadStream().CopyToAsync(reader);

            imageData = reader.ToArray(); 

            string base64Image = Convert.ToBase64String(imageData);

            url = $"""data:{image.ContentType};base64,{base64Image}""";

        }

        // Indicates that the page should rerender. 
        StateHasChanged();
    }

    // Handles the submitting of a new question to add. 
    private async Task HandleSubmit()
    {
        // Early return guard clause against no image existing. 
        if (image is null)
        {
            return;
        }

        // Initialises a question and ensures that the image was successfully translated by checking it is not null and throwing if it is. 
        Question question = new Question
        {
            FileName = image.Name,
            Data = imageData ?? throw new ArgumentNullException($"{nameof(imageData)} was null"), 
            ExamBoard = examBoard, 
            Level = level,
            Marks = marks
        };

        // Sends the question and image data and gets the HTTP response back. 
        var response = await Http.PutAsJsonAsync<Question>("https://localhost:7053/Image", question);

        // Ensures the file was successfully sent and, if the debug build is in use, logs a success message. Otherwise, simply returns. 
        if (response.IsSuccessStatusCode)
        {
            #if DEBUG
            Console.WriteLine("File sent successfully");

            Console.WriteLine($"Image Text: {await response.Content.ReadAsStringAsync()}");
            #endif

            return;
        }

        // If debug mode is in use, indicates that the file could not be sent and that an error occurred. 
        #if DEBUG
        Console.Error.WriteLine("FILE SENDING FAILED");
        #endif
    }
}
```
==== User-Management.razor
```cs
﻿This page has not been implemented. 
@page "/user-management"

<PageTitle>User Management</PageTitle>
```
==== View-Assignments.razor
```cs
﻿@*
    Page title, {ClassId:guid} indicates that the page should be provided with an ID for a class when initialised
    Injects an HTTP client via dependency injection.
    Also injects a local storage service.
    Also injects a navigation manager to allow the page to navigate the user to other pages. 
*@
@page "/view-assignments/{ClassId:guid}"
@inject HttpClient Http
@inject ILocalStorageService LocalStorage
@inject NavigationManager NavManager


<PageTitle>View Assignments</PageTitle>

@*Button that navigates the user to the add assignments page. *@
<button @onclick='() => NavManager.NavigateTo($"/add-assignment/{ClassId}")'>Add Assignment</button>

<hr/>

@*Ensures that assignments has been successfully retrieved from the server before rendering. *@
@if (assignments is not null)
{
    @*Renders each assignment with a button to view its questions, a button to view its results, and a button to remove the assignment*@
    @foreach (var (i, assignment) in assignments.WithIndex())
    {
        @assignment.Name

        <button @onclick="() => NavigateToViewIndividualAssignment(assignment)">View Assignment Questions</button>
        <button @onclick="() => NavigateToClassResultsForAssignment(assignment)">View Class Results</button>
        <button @onclick="() => RemoveAssignment(assignment)">Remove</button>

        <br>
    }
}


@code
{
    @*ID parameter the page was provided with. *@
    [Parameter]
    public Guid ClassId { get; set; }

    // The list of assignments the page retrieves from the server. 
    private List<Assignment>? assignments { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // Retrieves the assignments from the server and deserialises them into a list. 
        assignments = await Http.GetFromJsonAsync<List<Assignment>>($"https://localhost:7053/Class/{ClassId}/Assignments") ?? new List<Assignment>();

        await base.OnInitializedAsync();
    }

    // Navigates the user to the view-individual-assignment page which contains the questions, with the assignment ID to indicate what assignment is benig worked with. 
    private void NavigateToViewIndividualAssignment(Assignment assignment)
    {
        NavManager.NavigateTo($"/view-individual-assignment/{assignment.Id}");
    }

    // Navigates the user to the class-results page which contains the results for each class for each assignment, with the assignment ID to indicate what assignment is being worked with. 
    private void NavigateToClassResultsForAssignment(Assignment assignment)
    {
        NavManager.NavigateTo($"/class-results/{assignment.Id}");
    }

    // Ensures the assignment in question actually exists then first removes it from the list of assignments then rerenders then sends a delete request to the server to delete the assignment. 
    private async Task RemoveAssignment(Assignment assignment)
    {
        if (assignments is null)
        {
            return;
        }

        assignments.Remove(assignment);

        StateHasChanged();

        await Http.DeleteAsync($"/Assignment/{assignment.Id}");
    }
}
```
==== View-Classes-Assignments.razor
```cs
﻿@*
    Injects an HTTP client to allow the page to make requests to the server. 
    Injects a local storage service to allow the page handle local storage. 
    Injects a navigation manager to allow the page to redirect the user to other pages. 
*@
@page "/view-classes-assignments"
@inject HttpClient Http
@inject ILocalStorageService LocalStorage
@inject NavigationManager NavManager


<PageTitle>View Classes and Assignments</PageTitle>

@*Button that will navigate the user to the add-class page. *@
<button @onclick='() => NavManager.NavigateTo("/add-class")'>Add Class</button>

@*Ensures classes has been successfully retrieved from the server and does nothing if it has not or renders the classes if it has. *@
@if (classes is not null)
{
    @*// Loops through classes to render and renders each one with the index attached to not its position in the classes array. *@
    @foreach (var (i, _class) in classes.WithIndex())
    {
        @*// Renders the class' name. *@
        @_class.Name
        <br>
        @*// Loops through the students and renders each one. *@
        @foreach (var student in _class.Students)
        {
            @*
                StudentDisplayCheck is a component (found in Client/Shared) that renders a student with a checkbox next to it to handle situations such as this one
                This links the student used in the component to the current foreach variable student in the class. 
                This also links the IsChecked property of the component to use the IsStudentChecked to store its data. 
                It also links the OnCheck event to the Check method. 
            *@
            <StudentDisplayCheck Student="student" IsChecked="IsStudentChecked(_class, student)" OnCheck="(isChecked, student) => Check(_class, student, isChecked)"/>
        }

        @*
            Buttons that allow for functionality such as removing students that have been selected, navigating to the add-students-to-class page, removing an entire class, and navigating to the view-assignments page. 
        *@
        <button @onclick="() => RemoveStudents(classes[i])">Remove Selected Students</button>
        <button @onclick="() => NavigateToAddStudentsToClass(classes[i])">Add Students to Class</button>
        <button @onclick="() => RemoveClass(classes[i])">Remove Class</button>
        <button @onclick="() => NavigateToAssignments(classes[i])">View Assignments</button>

        <br>
    }
}

@code
{
    // The list of classes retrieved to used for this page. 
    private List<Class> classes { get; set; } = null!;
    // The hash set of all checks, it contains the hashes of tuples of classes and students. 
    // The presence of a class and student in checks indicates that the checkbox for that student/class combination has been checked. 
    HashSet<ValueTuple<Class, Student>> checks { get; set; } = null!;

    protected override async Task OnInitializedAsync()
    {
        // Retrieves the teacher from local storage. 
        Teacher teacher = await LocalStorage.GetItemAsync<Teacher>("user");

        // Retrieves the list of classes from the server. 
        classes = await Http.GetFromJsonAsync<List<Class>>($"https://localhost:7053/Teacher/{teacher.Id}/Classes") ?? new List<Class>();

        // Calculates how many students there are in the class. 
        int totalStudents = classes.Sum(_class => _class.Students.Count);

        // Assigns the checks HashSet with an initial capacity of the number of students to prevent dynamic resizing which can be slow and uses a great deal of memory. 
        checks = new HashSet<ValueTuple<Class, Student>>(totalStudents);

        await base.OnInitializedAsync();
    }

    // Removes checked students from a given class. 
    private async Task RemoveStudents(Class _class)
    {
        // Gets the students to remove from the class by matching them with a predicate check that they are contained within the checks HashSet. 
        var studentsToRemove = _class.Students.Where(student => checks.Contains((_class, student)));

        // Loops through each student and removes them from both the list of students and the checks variable. 
        foreach (Student student in studentsToRemove)
        {
            _class.Students.Remove(student);
            checks.Remove((_class, student));
        }

        // Indicates to rerender the component. 
        StateHasChanged();

        // Indicates to remove the selected students from the class. 
        await Http.PostAsJsonAsync($"https://localhost:7053/Class/{_class.Id}/Remove", studentsToRemove);
    }

    // Checks is used to represent the students which have their checkboxes checked. 
    // This checks that a student is present in the HashSet
    private bool IsStudentChecked(Class _class, Student student)
    {
        return checks.Contains((_class, student));
    }

    // This adds or removes the student/class combination from checks to indicate whether or not the student/class combination is currently checked. 
    private void Check(Class _class, Student student, bool isChecked)
    {
        if (isChecked)
        {
            checks.Add((_class, student));

            return;
        }

        checks.Remove((_class, student));
    }

    // This navigates the user to the add-students-to-class page with a class ID of that of the _class variable.
    private void NavigateToAddStudentsToClass(Class _class)
    {
        NavManager.NavigateTo($"/add-students-to-class/{_class.Id}");
    }

    // This navigates the user to the view-assignments page with a class ID of that of the _class variable.
    private void NavigateToAssignments(Class _class)
    {
        NavManager.NavigateTo($"/view-assignments/{_class.Id}");
    }

    // This removes a class from the list of classes then sends a delete request to the server to delete that class. 
    private async Task RemoveClass(Class @class)
    {
        classes.Remove(@class);

        StateHasChanged();

        await Http.DeleteAsync($"/Class/{@class.Id}");
    }
}
```
==== View-Individual-Assignment.razor
```cs
﻿@*
    Page title, {AssignmentId:guid} indicates that the page should be provided with an ID for an assignment when initialised
    Injects an HTTP client via dependency injection.
    Also injects a local storage service that allows for the page to access local storage.
    Also injects a navigation manager that can reroute the user.
*@
@page "/view-individual-assignment/{AssignmentId:guid}"
@using System.IO;
@inject HttpClient Http
@inject ILocalStorageService LocalStorage
@inject NavigationManager NavManager

<PageTitle>View Assignment Questions</PageTitle>

@*Ensures that assignment has been successfully retrieved before rendering the name and questions. *@
@if (assignment is not null)
{
    <h2>@assignment.Name</h2>

    @*Renders each question as its name followed by the image representing it. *@
    @foreach (Question question in assignment.Questions)
    {
        <hr>
        @Path.GetFileNameWithoutExtension(question.FileName)
        <br/>
        <img src="@question.ToDataUrl()"/>

        <br>
    }
}


@code
{
    @*ID parameter the page was provided with. *@
    [Parameter]
    public Guid AssignmentId { get; set; }

    // Represents the assignment to be retrieved from the database. 
    private Assignment? assignment { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // Retrieves the assignment from the database. 
        assignment = await Http.GetFromJsonAsync<Assignment?>($"https://localhost:7053/Assignment/{AssignmentId}/Withh?questions=true");

        // Logs if the assignment was unsuccessfully retrieved from the database. 
        if (assignment is null)
        {
            Console.Error.WriteLine($"Assignment with id {AssignmentId} not found");
        }

        await base.OnInitializedAsync();
    }
}
```
==== View-Mark-Schemes.razor
```cs
﻿@*This page has not been implemented*@
@page "/view-mark-schemes"

<PageTitle>View Mark Schemes</PageTitle>
```
==== View-Tests.razor
```cs
﻿@*This page has not been implemented*@
@page "/view-tests"

<PageTitle>View Tests</PageTitle>
```
=== Program.cs
```cs
using CourseworkPastPaperApplication2.Client;
using CourseworkPastPaperApplication2.Shared;
using Microsoft.AspNetCore.Components.Web;
using Microsoft.AspNetCore.Components.WebAssembly.Hosting;
using Blazored;
using Blazored.LocalStorage;
using System;
using Microsoft.AspNetCore.Components.Forms;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using System.Net.Http;

namespace CourseworkPastPaperApplication2.Client
{
    public class Program
    {
        // Async main to avoid blocking the browser page thread. 
        public static async Task Main(string[] args)
        {
            // Sets up the app. 
            var builder = WebAssemblyHostBuilder.CreateDefault(args);
            builder.RootComponents.Add<App>("#app");
            builder.RootComponents.Add<HeadOutlet>("head::after");

            // Adds an HttpClient per user. 
            builder.Services.AddScoped(sp => new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });
            // Adds local storage services
            builder.Services.AddBlazoredLocalStorage();
            
            WebAssemblyHost app = builder.Build();

            // Runs the app asynchronously to avoid blocking the browser page thread. 
            await app.RunAsync();
        }
    }
}
```
=== Properties
=== Shared
==== AddStudents.razor
```cs
﻿@*
    Injects an HTTP client to allow the component to work with HTTP requests. 
    Injects a local storage service to allow the component to work with the site's local storage. 
*@
@using MyProject.Components
@inject HttpClient Http
@inject ILocalStorageService LocalStorage

@*
    Creates an edit form with the model being the username. 
    When submitting, will search for a student using the username. 
*@
<EditForm OnSubmit="@SearchForStudent" Model="username">
    <label>
        Student Username
        <InputText @bind-Value=username/>
    </label>
    <button type="submit">Search</button>
</EditForm>

<h3>Class being made</h3>

@*Loops through each student that has been added and renders them with a button that will remove that student. *@
@foreach (Student student in Students)
{
    <label>
        @student.Name
        <button @onclick="() => HandleRemoveStudent(student)">Remove</button>
    </label>
}

<hr>

<h3>Search Results</h3>

@*Iterates through the search results for students and renders each student with a button that will add the student from the search results to the set of students. *@
@foreach (Student student in searchResults)
{
    <label>
        @student.Name
        <button @onclick="() => HandleAddStudent(student)">Add</button>
    </label>
}

@code
{
    // Represents the collection of students to be added. 
    // Note this is a set and so duplicates cannot be added. 
    [Parameter]
    public ISet<Student> Students { get; set; } = new HashSet<Student>();

    // Represents the function used to search for students. 
    [Parameter]
    public Func<Task> SearchForStudentsFunc { get; set; } = null!; 

    // Represents the username of the student(s) being searched for. 
    private string username = string.Empty;

    // Represents the set of search results. 
    private ISet<Student> searchResults = new HashSet<Student>();

    // Initialises the SearchForStudentsFunc function. 
    protected override void OnInitialized()
    {
        SearchForStudentsFunc = SearchForStudent; 

        base.OnInitialized();
    }

    // Function that searches for a student. 
    private async Task SearchForStudent()
    {
        // Ensures there is content within the username. 
        if (string.IsNullOrWhiteSpace(username))
        {
            return; 
        }

        // Retrieves the students that have a name similar to the username provided, either through the name containing the username (%{username}% wildcard comparison) or through the phonic representation (approximated by the soundex function) being equivalent for both. 
        searchResults = (await Http.GetFromJsonAsync<HashSet<Student>>($"https://localhost:7053/Student/SoundsLike/{username}") ?? new HashSet<Student>());

        // Removes all search results that are already contained in the set of students to add via the set exception operation. 
        searchResults.ExceptWith(Students);

        // Indicates to rerender the component. 
        StateHasChanged();
    }

    // Adds a student to set of students to add and removes them from the search results then rerenders the component. 
    private void HandleAddStudent(Student student)
    {
        Students.Add(student);

        searchResults.Remove(student);

        StateHasChanged();
    }

    // Removes a student from the results. 
    // Note that the student does not get readded to the search results. 
    // This is intentional as there then would be no way of clearing the search results of additional values after a new search without researching. 
    // E.g. If a search was performed an a student, "John", was added from a list of three other similar names, then a new search for students named "Jason" was performed and "John" was removed, "John" would be added to the set of "Jason"s which is undesired behaviour. 
    private void HandleRemoveStudent(Student student)
    {
        Students.Remove(student);

        StateHasChanged();
    }
}
```
==== Checkbox.razor
```cs
﻿@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@namespace MyProject.Components

@*
    Keeps track of a checkbox by binding its value to checked and when checked, calls the HandleChange function. 
    Also renders a Label provided to the component. 
*@
<label>
    <input type="checkbox" @bind="@Checked" @oninput="HandleChange" />
    @Label
</label>

@code 
{
    // Represents the label passed to the component to attach to the input. 
    [Parameter]
    public string Label { get; set; } = string.Empty;

    // Represents the value of whether or not the checkbox has been checked. 
    [Parameter]
    public bool Checked { get; set; }

    // This EventCallback is used by the Blazor framework to make bindings work (allows for syntax such as <Checkbox @bind-Checked="{variable}"/>).
    [Parameter]
    public EventCallback<bool> CheckedChanged { get; set; }

    // This EventCallback represents the function to be performed when the value is changed. 
    [Parameter]
    public EventCallback<bool> ValueChanged { get; set; }

    // This function handles the checking of the checkbox. 
    // It first converts the event arguments to their boolean value, representing whether or not it was checked. 
    // It then invokes the ValueChanged event callback then causes the page to rerender in case that is necessary. 
    private void HandleChange(ChangeEventArgs e)
    {
        Checked = (bool)e.Value!;
        ValueChanged.InvokeAsync(Checked);
        StateHasChanged();
    }
}
```
==== LoginComponent.razor
```cs
﻿@*
    Injects an HTTP client to allow the component to handle HTTP operations. 
    Injects a local storage service to allow the component to work with local storage. 
    Injects a navigation manager to allow the component to redirect the user. 
    Uses a type parameter which allows this component to work generically with multiple classes (Teacher and Student in this situation). 
*@
@using System.Text.Json
@inject HttpClient Http
@inject ILocalStorageService LocalStorage
@inject NavigationManager NavManager
@typeparam TUser

@*Login title with the string representation of the type. *@
<h1 style="font-family:'Cascadia Code'">Login @userType</h1>

@*
    This small code block contains the name identifiers. 
    E.g. teacher-name, teacher-password for teacher. 
    These are used for the text input boxes that follow. 
*@
@code
{
    string nameId => $"{userType.ToLower()}-name";
    string passwordId => $"{userType.ToLower()}-password";
}

@*
    Edit form for the user variable. 
    When submitted, calls the HandleSubmit function. 
    Form contains a username and a password. 
*@
<EditForm Model="user" OnSubmit="HandleSubmit">
    <InputText id="@nameId" placeholder="Full Name" @bind-Value="username" />
    <InputText id="@passwordId" placeholder="Password" type="password" @bind-Value="password" />
    <button type="submit">Login</button>
</EditForm>

@*Button to redirect to the sign-up page. *@
<button @onclick="ToSignUp">Sign Up</button>

@*Checks if any errors are present and displays them if they are. These are validation errors found by the server validation methods. *@
@if(errors.Any())
{
    <ul>
        @foreach (string error in errors)
        {
            <li>@error</li>
        }
    </ul>
}

@code
{
    // username and password used for binding to the form above. 
    // Accessor functions simply link directly to the corresponding properties on the user instance. 
    // Direct access is not supported by bindings and so this must be used. 
    private string username { get => user.Name; set => user.Name = value; }
    private string password { get => user.Password; set => user.Password = value; }

    // Gets the string representation of the type passed. 
    // E.g. "Teacher" for the Teacher class. 
    private string userType = typeof(TUser).Name;

    // User instance with unhashed (string form) password to use as a model for entering login details. 
    private UserWithUnencryptedPassword user = new UserWithUnencryptedPassword();
    // List of all validation errors found. 
    private List<string> errors = new List<string>();

    // Handles the submitting of a new login attempt. 
    private async Task HandleSubmit()
    {
        // If in debug, provides sensitive logging information. 
#if DEBUG
    Console.WriteLine($"Attempting to login user with name {user.Name}, password {user.Password}.");
#endif

        // Clears the errors whenever a new login attempt is submitted. 
        errors.Clear();

        // None of the following conditions should be possible without the user tampering with the console so just outputting "UNEXPECTED ERROR". 
        if (user.Name is null)
        {
            errors.Add("UNEXPECTED ERROR");
        }
        if (user.Password is null)
        {
            errors.Add("UNEXPECTED ERROR");
        }

        // Requests from the server whether or not the user is valid. 
        // HTTP Get does not allow for bodies so HTTP Post is used in its place. 
        var result = await Http.PostAsJsonAsync<UserWithUnencryptedPassword>($"https://localhost:7053/Validate{userType}", user);

        // Checks whether or not the user is valid. 
        // If valid, sets the "user" value in local storage. 
        // Then navigates to the homepage for that specific type. 
        // E.g. For teacher, navigates to teacher-homepage. 
        if (result.IsSuccessStatusCode)
        {
#pragma warning disable CS4014
            LocalStorage.SetItemAsync<User>("user", await result.Content.ReadFromJsonAsync<TUser>() ?? new TUser { Id = Guid.Empty, Name = "ERROR", Password = new byte[32] });
#pragma warning restore CS4014

            NavManager.NavigateTo($"/{userType.ToLower()}-homepage");

            return;
        }

        // If invalid, checks what type of invalid to know what validation errors to display. 
        switch (result.StatusCode)
        {
            // If status code is not found (404), adds a not found error. 
            case HttpStatusCode.NotFound:
                errors.Add($"User {user.Name} with given password not found.");
                break;
            // If status code indicates a generic bad request (400), error is an error in validating the properties of the user. 
            // So parses the contents of the HTTP response since that contains all validation errors. 
            // Then adds each one to the error list. 
            case HttpStatusCode.BadRequest:
                errors.Add($"User {user.Name} could not be validated.");
                JsonDocument doc = await JsonDocument.ParseAsync(result.Content.ReadAsStream());
                IEnumerable<KeyValuePair<string, string[]>> errorLists = doc.RootElement.GetProperty("errors").Deserialize<Dictionary<string, string[]>>() ?? Enumerable.Empty<KeyValuePair<string, string[]>>();

                foreach (var errorList in errorLists)
                {
                    foreach (var error in errorList.Value)
                    {
                        errors.Add($"{errorList.Key}\t:\t{error}");
                    }
                }
                break;
            // These are the only errors provided so the only other possibility would be that the server has crashed or been shut off so displays "UNEXPECTED ERROR"
            default:
                errors.Add("UNEXPECTED ERROR");
                break;
        }
    }

    // If in debug mode, logs that it is navigating to sign up. 
    // Navigates to sign-up. 
    private void ToSignUp()
    {
        #if DEBUG
        Console.WriteLine("Navigating to Sign-Up");
        #endif
        NavManager.NavigateTo("/sign-up");
    }
}
```
==== LoginComponent.razor.cs
```cs
﻿using CourseworkPastPaperApplication2.Shared;
using Microsoft.AspNetCore.Components;

namespace CourseworkPastPaperApplication2.Client.Shared
{
    // Restricts TUser used in the LoginComponent to be an instance of User and have a blank constructor. 
    public partial class LoginComponent<TUser> : ComponentBase where TUser : User, new()
    {
    }
}

```
==== MainLayout.razor
```cs
﻿@inherits LayoutComponentBase
@*
    Modified template file, used to contain a navigation side bar but that did not match with the needs of the client and so was removed. 
    Injects a local storage service. 
*@
@inject ILocalStorageService LocalStorage

<div class="page">
    <main>
        @*Renders the username retrieved from local storage in the top bar. *@
        <div class="top-row px-4">
            <p class="navbar-text">@username</p>
        </div>

        <article class="content px-4">
            @Body
        </article>
    </main>
</div>

@code
{
    // Stores the value of the username. 
    private string? username = null;

    // Adds an event handler to the local storage service that checks if the user has been assigned to and retrieves its new username and updates it if so. 
    protected override async Task OnInitializedAsync()
    {
        LocalStorage.Changed += (sender, e) =>
        {
            if (e.Key != "user")
            {
                return;
            }

            username = ((User)e.NewValue).Name;
        };

        await base.OnInitializedAsync();
    }
}
```
==== ResultsTableComponent.razor
```cs
﻿@using System.Linq
@inject HttpClient Http

<table class="table table-bordered">
    <thead>
        <tr>
            @*Renders the top row which is always students (and a blank row). *@
            @foreach (string studentName in Results.GetRow(0))
            {
                <th>@studentName</th>
            }
        </tr>
    </thead>
    <tbody>
        @*Renders each subsequent row. The 1 in WithIndex(1) skips the first row but maintains correct index position. *@
        @foreach (var (i, row) in Results.WithIndex(1))
        {
            @*Splits each row into the first element and the rest then stores the rest in the scores variable (The first column of each row following the first is a question). *@
            <tr>
                <td>@row.IndexedPartition(0, out IEnumerable<string> scores).First()</td>

                @*Retrieves the scores variable that represents all values but the question so therefore all the score and what they are out of and renders them with an input field that allows the user to change the score for a student for a question. *@
                @foreach (var (j, result) in (scores ?? Enumerable.Empty<string>()).WithIndex())
                {
                    <td>@result <input @oninput="e => HandleInput(e, i, j + 1)"/></td>
                }
            </tr>
        }
    </tbody>
</table>

@*Causes all inputted scores to be saved to the database. Calls the SaveNewMarks function. *@
<button @onclick="SaveNewMarks">Save new marks</button>

@code 
{
    // Results table passed in as a component parameter. The table above is built from this table. 
    [Parameter] 
    public ResultsTable Results { get; set; } = null!;

    // Function provided by the page creating this that handles what to do with the updated paper results. 
    // Currently in the class-results page, this simply saves each new result to the database. 
    [Parameter]
    public EventCallback<IEnumerable<PaperResult>> OnSaveChanges { get; set; }

    // Positive-only integers that represent the updated. 
    // Keeps track of all scores provided by the score inputs. 
    private uint[,] editBoxValues { get; set; } = null!;

    // Temporary variable that keeps track of scores after the indexed partition from the row to questions and scores. 
    private IEnumerable<string>? scores { get; set; }

    protected override void OnInitialized()
    {
        // Instanitates the editBoxValues to be one less than the results and column to account for the row and column that is the student names and the questions. 
        editBoxValues = new uint[Results.Rows - 1, Results.Columns - 1];

        base.OnInitialized();
    }

    // Handles new score being input. 
    private void HandleInput(ChangeEventArgs e, int i, int j)
    {
        // Gets the string value of the input. 
        string newValue = (string?)e.Value ?? string.Empty;

        // Predicate that checks the value is a non-negative integer that is not greater than the total marks the question is out of. 
        if (ValidateForNewResult(newValue, Results[i, j]))
        {
            // Replaces value in the table with new value. 
            ReplaceResultsValue(newValue, i, j);

            // Parses the value and assigns it into editBoxValues so it can be used later without having to reparse from Results. 
            editBoxValues[i - 1, j - 1] = uint.Parse(newValue);
        }
    }

    // Checks input is a valid integer between 0 and the maximum mark for the question (inclusive). 
    private bool ValidateForNewResult(string value, string result)
    {
        // Ensures the value is a valid integer >= 0 by trying to parse as an unsigned integer. 
        bool isValidInteger = uint.TryParse(value, out uint valueAsUnsignedInteger);

        // Early returns if invalid. 
        if (!isValidInteger)
        {
            return false;
        }

        // Retrieving this value as a span is a small optimisation that prevents unnecessary allocation in the slice part to follow. 
        // The equivalent string function, substring creates an entire new string whereas this merely provides a modified view over the current string. 
        var resultAsSpan = result.AsSpan();

        // Gets the index of the slash in the marks. 
        // Marks are in the form {score}/{totalMarks}.
        // E.g. 7/15. 
        // Therefore, the value after the '/' is the total mark for the question. 
        int slashIndex = resultAsSpan.IndexOf('/');

        // Gets the maximum marks from after the '/' onwards and returns whether or not the value being checked is less than or equal to the total marks. 
        uint maxMarksForQuestion = uint.Parse(resultAsSpan.Slice(slashIndex + 1));

        return valueAsUnsignedInteger <= maxMarksForQuestion;
    }

    // Calls the OnSaveChanges EventCallback that was providided by the page using this component. 
    // Calls it using the ResultsAsEnumerable function which is below. 
    // This function converts the results table to a collection of paper results. 
    private async Task SaveNewMarks()
    {
        await OnSaveChanges.InvokeAsync(ResultsAsEnumerable());
    }

    // This converts the results table to a collection of paper results. 
    private IEnumerable<PaperResult> ResultsAsEnumerable()
    {
        for (int i = 0; i < Results.Rows - 1; i++)
        {
            for (int j = 0; j < Results.Columns - 1; j++)
            {
                // Retrieves the student and the question the specified indices. 
                var student = Results.Students[j];
                var question = Results.Questions[i];

                // Finds the paper result that matches the two values above (student, question). 
                PaperResult oldResult = student.PaperResults.First(paperResult => paperResult.QuestionId == question.Id);

                // Reassigns the old paper result's score to the new score. 
                oldResult.Score = (int)editBoxValues[i, j];

                // Yields the result. 
                yield return oldResult;
            }
        }
    }

    // This finds the result corresponding to the two indices provided and reassigns the score to the value provided. 
    private void ReplaceResultsValue(string value, int i, int j)
    {
        // Gets the result corresponding to the two indices provided. 
        string result = Results[i, j];

        // Gets the index of the '/' that separates the score from the total marks. 
        int slashIndex = result.IndexOf('/');

        // Reassigns the result to be the new value concatenated with the old value from the '/' onwards. 
        // Id est, the '/' and the total mark. 
        Results[i, j] = value + result.Substring(slashIndex);

        // Rerenders for the new change. 
        StateHasChanged();
    }
}
```
==== SearchForQuestion.razor
```cs
﻿@*
    This component injects an HTTP client so it can handle HTTP request operations. 
*@
@inject HttpClient Http

@*
    Text input for keywords to search for. 
    Binds the value to the keyword variable. 
    Button below adds a keyword via the AddKeyword function. 
*@
<InputText placeholder="Keyword to search for" @bind-Value="keyword"/>
<button @onclick="AddKeyword">Add Keyword</button>

@*This lists all keywords from questionSearchModel.KeywordsList with each having a button to remove the keword from the list of keywords and rerender the component. *@
<h3>Keywords</h3>
<ul>
    @foreach (string keyword in questionSearchModel.KeywordsList)
    {
        @keyword
        <button @onclick="() => { questionSearchModel.KeywordsList.Remove(keyword); StateHasChanged(); }">Remove Keyword</button>
    }
</ul>

@*Ensures options has been successfully retrieved from the server. *@
@if (options is not null)
{
    @*Renders each level as a checkbox with a label indicating the name of the level next to it. *@
    @foreach (var level in options.Levels)
    {
        <input type="checkbox" @onchange="e => HandleBoxCheck<Level>(e, level, levels)"/> @level.Name
    }
    <br>
    <hr>
    @*Renders each exam board as a checkbox with a label indicating the name of the exam board next to it. *@
    @foreach (var examBoard in options.ExamBoards)
    {
        <input type="checkbox" @onchange="e => HandleBoxCheck<ExamBoard>(e, examBoard, examBoards)" /> @examBoard.Name
    }
}

@*Checkbox for whether or not to search for only questions that match all keywords or to take questions ordered by how many matches. *@
<br/>
<span class="text-success">🗸</span>  Search for matches on all keywords <br/>
<span class="text-danger">x</span>:  Get most matches possible
<br/>
<InputCheckbox @bind-Value="all"/>

@*Clicking this button will call the SearchForMatchingQuestions function and search for matching questions and assign them to questions. *@
<button @onclick="SearchForMatchingQuestions">Search for Questions</button>

@*Ensures that questions have been retrieved already and that questions were actually retrieved. *@
@if (questions is not null && questions.Any())
{
    @*Button to clear retrieved questions, calls the ClearQuestions function. *@
    <button @onclick="() => ClearQuestions(questions)">Clear</button>
    <br>

    @*
        Renders each question's image with a button that removes the question from the search results and calls 
        the OnQuestionSelected event callback which is provided by the page containing the component and in the 
        one use case in this codebase, adds it to a set of questions that are then added. 
    *@
    @foreach (Question question in questions)
    {
        <img src="@question.ToDataUrl()"/>
        <button @onclick="() => HandleQuestionSelected(questions, question)">Select this Question</button>
    }
}

@code
{
    // Event callback provided by the page containing this that does something with a selected question. 
    // In the one use case in this codebase, this adds to a set of questions that are then sent to the server to create a new assignment. 
    [Parameter]
    public EventCallback<Question> OnQuestionSelected { get; set; }

    // all used for binding to the InputCheckbox above.
    // Accessor functions simply link directly to the corresponding properties on the QuestionSearchModel instance.
    // Direct access is not supported by bindings and so this must be used.
    // This indicates whether to get only question that match all keywords or instead to get quetsions ordered by the number of matches. 
    private bool all 
    { 
        get => questionSearchModel.All; 
        set => questionSearchModel.All = value; 
    }

    // Set of questions retrieved in search. 
    private HashSet<Question>? questions { get; set; }

    // Set of levels, set of exam boards that have been selected to be searched in the question search. 
    // HashSets used to speed up accessing to O(1). 
    private HashSet<Level> levels { get; set; } = new HashSet<Level>();
    private HashSet<ExamBoard> examBoards { get; set; } = new HashSet<ExamBoard>();

    // The QuestionSearchModel used for searching for questions. 
    // This contains filters that are used to find the correct questions. 
    private QuestionSearchModel questionSearchModel = new QuestionSearchModel { KeywordsList = new HashSet<string>() };
    // The current keyword that has just been typed. 
    private string keyword { get; set; } = string.Empty;

    // options represents the radio filter options from the database. 
    // These are then selected as part of the searching process. 
    private RadioOptions? options { get; set; }

    // This simply removes all the questions then rerenders the component. 
    private void ClearQuestions(HashSet<Question> questions)
    {
        questions.Clear();

        StateHasChanged();
    }

    // This simply removes the question from the search results and rerenders the component to show its removal. 
    // It then invokes the OnQuestionSelected event callback provided to it by the page containing it. 
    private async Task HandleQuestionSelected(HashSet<Question> questions, Question question)
    {
        questions.Remove(question);

        StateHasChanged();

        await OnQuestionSelected.InvokeAsync(question);
    }

    // This searches for questions that match the questionSearchModel filters. 
    private async Task SearchForMatchingQuestions()
    {
        // Sends a request to the server to retrieve the questions. 
        // HTTP Get requests do not have bodies and so an HTTP Post request is used in its place. 
        var response = await Http.PostAsJsonAsync("https://localhost:7053/Question", questionSearchModel);

        // Reads the response's content as a hash set of questions and assigns that to questions. 
        questions = await response.Content.ReadFromJsonAsync<HashSet<Question>>();

        // Rerenders the component to display the new questions. 
        StateHasChanged();
    }

    // Generic function used for checking the boxes for the levels and for the exam boards. 
    private void HandleBoxCheck<T>(ChangeEventArgs e, T item, ICollection<T> values)
    {
        // Checks to ensure the value of the event argument exists. 
        // If not, early return (Guard Clause). 
        if (e.Value is null)
        {
            return;
        }

        // Checks if checkbox has just been checked and adds to the collection of values (levels or exam boards to filter by in the use case above) if true. 
        if ((bool)e.Value)
        {
            values.Add(item);

            return;
        }

        // Otherwise, removes the item from the collection. 
        values.Remove(item);
    }

    protected override async Task OnInitializedAsync()
    {
        // Retrieves all options from the server or initialises to empty collections of options if the options cannot be found from the server. 
        options = await Http.GetFromJsonAsync<RadioOptions>("https://localhost:7053/Options") ?? new RadioOptions(ExamBoards: Array.Empty<ExamBoard>(), Levels: Array.Empty<Level>());

        // Assigns the options on the search model to the empty sets to keep them synchronised. 
        questionSearchModel.ExamBoards = examBoards;
        questionSearchModel.ValidLevels = levels;

        await base.OnInitializedAsync();
    }

    // Adds a keyword to the search models keyword list. 
    private void AddKeyword()
    {
        // Ensures the keyword is not purely whitespace and early returns if it is (Guard Clause). 
        if (string.IsNullOrWhiteSpace(keyword))
        {
            return;
        }

        // Adds the keyword to the keywords in the question search model. 
        // Note that the keywords in the question search model are represented by a HashSet and so cannot contain duplicate keywords. 
        questionSearchModel.KeywordsList.Add(keyword);

        // Reassigns keyword to be an empty string. This will also clear the input text field as their values are bound. 
        keyword = string.Empty;

        // Rerenders the component to display the new changes. 
        StateHasChanged();
    }
}
```
==== SignUpComponent.razor
```cs
﻿@*
    Injects an HTTP client to allow the component to handle HTTP operations.
    Injects a navigation manager to allow the component to redirect the user.
    Uses a type parameter which allows this component to work generically with multiple classes (Teacher and Student in this situation).
*@
@using System.Text.Json
@inject HttpClient Http
@inject NavigationManager NavManager
@typeparam TUser

@*Login title with the string representation of the type. *@
<h1 style="font-family:'Cascadia Code'">Sign Up @userType</h1>

@*
    This small code block contains the name identifiers.
    E.g. teacher-name, teacher-password for teacher.
    These are used for the text input boxes that follow.
*@
@code
{
    string nameId => $"{userType.ToLower()}-name";
    string passwordId => $"{userType.ToLower()}-password";
}

@*
    Edit form for the user variable.
    When submitted, calls the HandleSubmit function.
    Form contains a username and a password.
*@
<EditForm Model="user" OnSubmit="HandleSubmit">
    <InputText id="@nameId" placeholder="Full Name" @bind-Value="username" />
    <InputText id="@passwordId" placeholder="Password" type="password" @bind-Value="password" />
    <button type="submit">Submit</button>
</EditForm>

@*Checks if any errors are present and displays them if they are. These are validation errors found by the server validation methods. *@
@if (errors.Any())
{
    <ul>
        @foreach (string error in errors)
        {
            <li>@error</li>
        }
    </ul>
}

@code
{
    // username and password used for binding to the form above.
    // Accessor functions simply link directly to the corresponding properties on the user instance.
    // Direct access is not supported by bindings and so this must be used.
    private string username { get => user.Name; set => user.Name = value; }
    private string password { get => user.Password; set => user.Password = value; }

    // Gets the string representation of the type passed.
    // E.g. "Teacher" for the Teacher class.
    private string userType = typeof(TUser).Name;

    // User instance with unhashed (string form) password to use as a model for entering sign-up details. 
    private UserWithUnencryptedPassword user = new UserWithUnencryptedPassword();
    // List of all validation errors found. 
    private List<string> errors = new List<string>();

    // Handles the submitting of a new login attempt.
    private async Task HandleSubmit()
    {
        // If in debug, provides sensitive logging information. 
#if DEBUG
    Console.WriteLine($"Attempting to sign-up user with name {user.Name}, password {user.Password}.");
#endif

        // Clears the errors whenever a new login attempt is submitted.
        errors.Clear();

        // None of the following conditions should be possible without the user tampering with the console so just outputting "UNEXPECTED ERROR".
        if (user.Name is null)
        {
            errors.Add("UNEXPECTED ERROR");
        }
        if (user.Password is null)
        {
            errors.Add("UNEXPECTED ERROR");
        }

        // Requests from the server whether or not the user is valid.
        // HTTP Get does not allow for bodies so HTTP Post is used in its place.
        var result = await Http.PostAsJsonAsync<UserWithUnencryptedPassword>($"https://localhost:7053/SignUp{userType}", user);

        // Checks whether or not the user is valid.
        // If valid, navigates to the login page. 
        if (result.IsSuccessStatusCode)
        {
            #if DEBUG
            Console.WriteLine("Navigating to Login");
            #endif
            NavManager.NavigateTo("/");

            return;
        }

        // If invalid, checks what type of invalid to know what validation errors to display.
        switch (result.StatusCode)
        {
            // If status code indicates a generic bad request (400), error is an error in validating the properties of the user.
            // So parses the contents of the HTTP response since that contains all validation errors.
            // Then adds each one to the error list.
            case HttpStatusCode.BadRequest:
                errors.Add($"User {user.Name} could not be validated.");
                JsonDocument doc = await JsonDocument.ParseAsync(result.Content.ReadAsStream());
                var errorLists = doc.RootElement.GetProperty("errors").Deserialize<Dictionary<string, string[]>>() ?? Enumerable.Empty<KeyValuePair<string, string[]>>();

                foreach (var errorList in errorLists)
                {
                    foreach (var error in errorList.Value)
                    {
                        errors.Add($"{errorList.Key}\t:\t{error}");
                    }
                }
                break;
            // If status code is conflict (409), adds a conflict error.
            case HttpStatusCode.Conflict:
                errors.Add($"Account with username {user.Name} already exists.");
                break;
            // These are the only errors provided so the only other possibility would be that the server has crashed or been shut off so displays "UNEXPECTED ERROR"
            default:
                errors.Add("UNEXPECTED ERROR");
                break;
        }
    }
}
```
==== SignUpComponent.razor.cs
```cs
﻿using CourseworkPastPaperApplication2.Shared;
using Microsoft.AspNetCore.Components;

namespace CourseworkPastPaperApplication2.Client.Shared
{
    // Restricts TUser used in the SignUpComponent to be an instance of User and have a blank constructor. 
    public partial class SignUpComponent<TUser> : ComponentBase where TUser : User, new()
    {
    }
}

```
==== StudentDisplayCheck.razor
```cs
﻿@using Microsoft.AspNetCore.Components.Web
@namespace MyProject.Components

@*
    Uses the custom Checkbox component to access functionality not available with InputCheckbox. 
    Sets the checkbox to have a label of the student's name. 
    Binds the value to the IsChecked parameter. 
    When the value is changed, invokes the HandleCheck function. 
*@
<div class="rectangle">
    <Checkbox Label="@Student.Name" @bind-Checked="IsChecked" ValueChanged="HandleCheck"/>
</div>

@code 
{
    // Represents whether or not the checkbox is checked. 
    [Parameter]
    public bool IsChecked { get; set; }

    // Represents the student this StudentDisplayCheck is representing. 
    [Parameter]
    public Student Student { get; set; } = null!;

    // Subroutine provided from outside the component, invoked when the checkbox is checked. 
    [Parameter]
    public Action<bool, Student>? OnCheck { get; set; }

    // Calls the OnCheck subroutine and rerenders the component. 
    private void HandleCheck(bool isChecked)
    {
        OnCheck?.Invoke(isChecked, Student);
        StateHasChanged();
    }
}
```
=== wwwroot
==== css
===== bootstrap
===== open-iconic
====== font
======= css
======= fonts
=== _Imports.razor
```cs
﻿@*This file provides global namespace inclusions across all pages/components to save from rewriting the generic ones every time*@
@using System.Net
@using System.Net.Http
@using System.Net.Http.Json

@using MyProject.Components

@using Blazored.LocalStorage

@using System.Collections.Generic

@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.WebAssembly.Http
@using Microsoft.AspNetCore.Components.Web.Virtualization

@using CourseworkPastPaperApplication2.Shared
@using CourseworkPastPaperApplication2.Client
@using CourseworkPastPaperApplication2.Client.Shared
```
== Server
=== bin
==== Debug
===== net7.0
====== BlazorDebugProxy
====== de
====== de-DE
====== x64
====== x86
==== Release
===== net7.0
=== CourseworkPastPaperApplication2.Server.csproj
```cs
﻿<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>disable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Bogus" Version="34.0.2" />
    <PackageReference Include="FluentValidation" Version="11.5.2" />
    <PackageReference Include="Microsoft.AspNet.WebApi.Client" Version="5.2.9" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.Server" Version="7.0.5" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="7.0.5" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="7.0.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="7.0.3" />
    <PackageReference Include="System.Linq.Async" Version="6.0.1" />
    <PackageReference Include="Tesseract" Version="5.2.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Client\CourseworkPastPaperApplication2.Client.csproj" />
    <ProjectReference Include="..\Shared\CourseworkPastPaperApplication2.Shared.csproj" />
  </ItemGroup>


</Project>
```
=== EndpointFunctions.cs
```cs
﻿using CourseworkPastPaperApplication2.Server;
using CourseworkPastPaperApplication2.Shared;
using FluentValidation;
using FluentValidation.Results;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
//using CourseworkPastPaperApplication.Shared;
namespace CourseworkPastPaperApplication2
{
    internal static class EndpointFunctions
    {
        // Gets all students in a class
        public static async Task<IEnumerable<Student>?> GetStudentsInClass([FromRoute] Guid classId, [FromServices] PapersDbContext db)
        {
            return await
                (
                from _class in db.Classes
                where _class.Id == classId
                select _class.Students
                ).FirstOrDefaultAsync();
        }

        // Signs up (adds) a new user if the user is valid. 
        // Uses a generic type parameter to build separate functions for the Teacher and the Student types with a single definition. 
        public static async Task<IResult> SignUp<TUser>([FromServices] UserValidator validator, [FromServices] PasswordHasher<string> hasher, [FromServices] PapersDbContext db, [FromBody] UserWithUnencryptedPassword user) where TUser : User, new()
        {
            // Uses the UserValidator added in the services part of the program to validate the users.
            ValidationResult validationResult = await validator.ValidateAsync(user);

            // Gets the corresponding table for the type of the current user. 
            DbSet<TUser> userSet = GetSet<TUser>(typeof(TUser), db);

            // Checks if the user is in the database. 
            Task<bool> inDatabase = userSet.AnyAsync(queryUser => queryUser.Name == user.Name);

            if (!validationResult.IsValid)
            {
                // Gets a dictionary of all errors
                Dictionary<string, string[]> errors = validationResult.Errors.ToDictionary();
                // If in debug mode, writes all errors to the console log. 
#if DEBUG
                Console.WriteLine(JsonSerializer.Serialize(errors));
#endif
                // Returns an HTTP 400 with all validation errors. 
                return Results.ValidationProblem(errors);
            }

            // If the user is present, returns an HTTP 409 with the user data. 
            if (await inDatabase)
            {
                return Results.Conflict(user);
            }

            //
            TUser userToAdd = new TUser
            {
                Name = user.Name,
                PasswordAsHex = hasher.HashPassword(user.Name, user.Password)
            };

            await userSet.AddAsync(userToAdd);

            // Trys to save changes, if failure, returns an HTTP 500. 
            try
            {
                await db.SaveChangesAsync();
            }
            catch (DbUpdateException)
            {
                return Results.StatusCode(500);
            }

            return Results.Created(nameof(GetTeacherById), userToAdd);
        }

        // Adds an assignment to a class. 
        public static async Task AddAssignmentToClass([FromRoute] Guid classId, [FromBody] Assignment assignment, [FromServices] PapersDbContext db)
        {
            // Finds the class indicated by classId
            Class? @class = await db.Classes.Include(cl => cl.Students).FirstOrDefaultAsync(cl => cl.Id == classId);

            if (@class is null)
            {
                throw new KeyNotFoundException($"{classId} was not found in {nameof(db.Classes)}");
            }

            // Adds the assignment to the database.
            await db.Assignments.AddAsync(assignment);

            // Adds each a blank PaperResult for each student, for each question for the assignment. 
            foreach (var student in @class.Students)
            {
                foreach (Question question in assignment.Questions)
                {
                    PaperResult blankPaperResult = new PaperResult
                    {
                        Assignment = assignment,
                        Question = question,
                        Student = student
                    };

                    await db.PaperResults.AddAsync(blankPaperResult);
                    student.PaperResults.Add(blankPaperResult);
                }
            }

            // Attaches questions so they are not duplicated in the database. 
            db.Questions.AttachRange(assignment.Questions);

            // Adds the assignment to the class. 
            @class.Assignments.Add(assignment);

            // Saves Changes
            await db.SaveChangesAsync();
        }

        // Adds a collection of students to a given class
        public static async Task AddStudentsToClass([FromRoute] Guid classId, [FromBody] IEnumerable<Student> students, [FromServices] PapersDbContext db)
        {
            // Finds the class. 
            Class @class = await db.Classes.FindAsync(classId) ?? throw new KeyNotFoundException();

            // Adds each student to the class. 
            foreach (Student student in students)
            {
                @class.Students.Add(student);
            }

            await db.SaveChangesAsync();
        }

        // Adds a class to a teacher. 
        public static async Task AddTeacherClass([FromRoute] Guid teacherId, [FromServices] PapersDbContext db, [FromBody] Class classBase)
        {
            // Finds the teacher. 
            Teacher? teacher = await db.Teachers.FindAsync(teacherId);

            // If no teacher was found, early return (Guard Clause)
            if (teacher is null)
            {
                return;
            }

            // Attaches each student in the new class to the database facade to ensure they are not duplicated on adding the class. 
            db.Students.AttachRange(classBase.Students);

            // Adds the class to the database
            db.Classes.Add(classBase);

            // Adds the class to the teacher.
            teacher.Classes.Add(classBase);

            // Saves changes
            await db.SaveChangesAsync();
        }

        // Checks if a PasswordVerificationResult was successful or not via pattern matching. 
        public static bool CheckValidVerificationResult(PasswordVerificationResult result) => result is PasswordVerificationResult.Success or PasswordVerificationResult.SuccessRehashNeeded;

        // Gets an assignment from an id. 
        public static async Task<Assignment?> GetAssignment([FromRoute] Guid assignmentId, [FromServices] PapersDbContext db)
        {
            return await db.Assignments.FindAsync(assignmentId);
        }

        // Returns a ResultsTableInitialisationComponents object such that the client can build an a ResultsTable from them. 
        public static async Task<ResultsTableInitialisationComponents?> GetAssignmentResults([FromRoute] Guid assignmentId, [FromServices] PapersDbContext db)
        {
            // Query that gets the assignments and all their questions and all the students that have the assignment as well as all their results for the questions. 
            var assignment = await db.Assignments
                .Include(@assignment => @assignment.Questions)
                .Include(@assignment => @assignment.Class.Students)
                .ThenInclude(student => student.PaperResults)
                .Select(assignment => new { assignment.Name, assignment.Id, assignment.Class, Questions = assignment.Questions.Select(question => new Question { FileName = question.FileName, Id = question.Id, Marks = question.Marks }) })
                .FirstOrDefaultAsync(a => a.Id == assignmentId);

            // Early return if assignment was not found. 
            if (assignment is null)
            {
                return null;
            }

            // Instantiates and returns the ResultsTableInitialisationComponents object with the retrieved data. 
            return new ResultsTableInitialisationComponents { Students = assignment.Class.Students.ToArray(), Id = assignment.Id, Name = assignment.Name, Questions = assignment.Questions.ToArray() };
        }

        // Gets assignments with properties included, as specified by query parameters in the URL. (Currently only questions, this function was build with extension in mind)
        public static async Task<Assignment?> GetAssignmentWith([FromRoute] Guid assignmentId, [FromServices] PapersDbContext db, [FromQuery] bool questions = false)
        {
            IQueryable<Assignment> assignments = db.Assignments;

            if (questions)
                assignments = assignments.Include(assignment => assignment.Questions);

            return await assignments.FirstOrDefaultAsync(assignment => assignment.Id == assignmentId);
        }

        // Gets all assignments for a class
        public static async Task<IEnumerable<Assignment>> GetClassAssignments([FromRoute] Guid classId, [FromServices] PapersDbContext db)
        {
            // Gets the specified class with all its assignments
            Class? @class = await db.Classes.Include(@class => @class.Assignments).FirstOrDefaultAsync(@class => @class.Id == classId);

            // If no class was found, logs an error and returns an empty collection of Assignments
            if (@class is null)
            {
                Console.WriteLine("Error in retrieving class");

                return Enumerable.Empty<Assignment>();
            }

            return @class.Assignments;
        }

        // Gets all classes
        public static IEnumerable<Class> GetClasses([FromServices] PapersDbContext db) => db.Classes;

        // Gets all the PaperResults for a specific student for a specific assignment
        public static IEnumerable<PaperResult> GetPaperResultsForSpecificStudentAssignment([FromServices] PapersDbContext db, [FromRoute] Guid assignmentId, [FromRoute] Guid studentId)
        {
            // matches assignment id then student id. 
            return db.PaperResults.Where(paperResult => paperResult.AssignmentId == assignmentId)
                                  .Where(paperResult => paperResult.StudentId == studentId);
        }

        // Gets all questions of a given set of questions that match keywords specified in the provided search model. 
        public static IAsyncEnumerable<Question> GetQuestionsThatMatchKeywords(QuestionSearchModel searchModel, IQueryable<Question> questionsOfCorrectExamBoardAndLevel)
        {
            IAsyncEnumerable<Question> questions = questionsOfCorrectExamBoardAndLevel.AsAsyncEnumerable();

            // If specified for all keywords to match, only returns where all keywords are included in the read data of the question. (This matching is only around 95-98% accurate)
            if (searchModel.All)
            {
                return
                    from question in questions
                    where searchModel.KeywordsList.All(keyword => question.ReadData.Contains(keyword))
                    select question;
            }

            // Orders by the number of matching keywords
            return
                from question in questions
                orderby searchModel.KeywordsList.Count(keyword => question.ReadData.Contains(keyword))
                descending
                select question;
        }

        // Gets questions specified by a search model. 
        // Only returns CountOfQuestionsToReturn questions. 
        public static IAsyncEnumerable<Question> GetQuestionsWithFilters([FromBody] QuestionSearchModel searchModel, [FromServices] PapersDbContext db)
        {
            /// Limiting the number of questions to return to avoid issues with memory
            const int CountOfQuestionsToReturn = 5;

            // Retrieves where exam board and level matches. 
            IQueryable<Question> questionsOfCorrectExamBoardAndLevel = from question in db.Questions
                                                                       where searchModel.ExamBoards.Contains(question.ExamBoard)
                                                                       where searchModel.ValidLevels.Contains(question.Level)
                                                                       select question;

            // Gets questions that match keywords.
            return GetQuestionsThatMatchKeywords(searchModel, questionsOfCorrectExamBoardAndLevel).Take(CountOfQuestionsToReturn);
        }

        // Gets all radio options (exam boards, levels)
        public static async Task<RadioOptions> GetRadioOptions([FromServices] PapersDbContext db)
        {
            return new RadioOptions(Levels: await db.Levels.ToArrayAsync(), ExamBoards: await db.ExamBoards.ToArrayAsync());
        }

        // Gets the database table set for a given type (avoiding being fully generic for performance). 
        public static DbSet<TUser> GetSet<TUser>(Type type, PapersDbContext db) where TUser : User => (DbSet<TUser>)(object)(type == typeof(Teacher) ? db.Teachers : db.Students);

        // Gets all students that match a given name as either like the name or matching the Soundex form of the name to the Soundex form of the student's name. 
        // Soundex is an algorithm that approximates what a word should sound like. 
        public static IQueryable<Student> GetSoundsLike([FromServices] PapersDbContext db, [FromRoute] string username)
        {
            var matches = db.Students.Where(student => PapersDbContext.Soundex(student.Name) == PapersDbContext.Soundex(username) || EF.Functions.ILike(student.Name, $"%{username}%"));
            return matches;
        }

        // Retrieves all students
        public static IEnumerable<Student> GetStudents([FromServices] PapersDbContext db) => db.Students;

        // Gets teacher with id
        public static async Task<Teacher?> GetTeacherById([FromServices] PapersDbContext db, [FromRoute] Guid Id)
        {
            return await db.Teachers.FirstOrDefaultAsync(teacher => teacher.Id == Id);
        }

        // Gets all classes of a teacher. 
        public static async Task<IEnumerable<Class>?> GetTeacherClasses([FromServices] PapersDbContext db, [FromRoute] Guid teacherId)
        {
            Teacher? teacher = await db.Teachers.Include(teacher => teacher.Classes).ThenInclude(_class => _class.Students).FirstOrDefaultAsync(teacher => teacher.Id == teacherId);
            return teacher?.Classes;
        }

        // Gets all teachers. 
        public static IEnumerable<Teacher> GetTeachers([FromServices] PapersDbContext db) => db.Teachers;

        // Reads in a given image file and adds it and an associated question to the database. 
        // This method is wasteful of memory. If bottlenecks arise, this should be refactored first. 
        // A possible issue could be for a file that is too large. If this is an issue, using multiple requests to send the data property should be considered. 
        public static async Task<IResult> ReadInImageFile([FromBody] Question questionBase, [FromServices] PapersDbContext db)
        {
            if (questionBase.ExamBoard is not null)
                questionBase.ExamBoard = (await db.ExamBoards.FindAsync(questionBase.ExamBoard.Id))!;
            if (questionBase.Level is not null)
                db.Levels.Attach(questionBase.Level);

            // Uses the Tesseract OCR to attempt to read the image to provide the ReadData property of the Question class. 
            questionBase.ReadData = await ImageReader.ReadImageAsync(questionBase.Data);

            // Adds the question to the database. 
            // The question was already pre-built by the client, hence why it only needs the ReadData property being assigned to. 
            await db.Questions.AddAsync(questionBase);

            // Saves
            await db.SaveChangesAsync();

            // Returns HTTP 200 with the questions read data. 
            return Results.Ok(questionBase.ReadData);
        }

        // Deletes an assignment from the database. 
        public static async Task RemoveAssignment([FromRoute] Guid AssignmentId, [FromServices] PapersDbContext db)
        {
            // Creates a new assignment to be attached to the database so it can be removed. 
            var assignment = new Assignment { Id = AssignmentId };

            // Attaches the assignment to the database so it can be removed. 
            db.Assignments.Attach(assignment);

            // Removes the assignment from the database. 
            db.Assignments.Remove(assignment);

            // Saves the changes. 
            await db.SaveChangesAsync();
        }

        public static async Task RemoveClass([FromRoute] Guid classId, [FromServices] PapersDbContext db)
        {
            // Creates a new class to be attached to the database so it can be removed. 
            Class @class = new Class { Id = classId };

            // Attaches the class to the database so it can be removed. 
            db.Classes.Attach(@class);

            // Removes the class from the database. 
            db.Classes.Remove(@class);

            // Saves the changes.
            await db.SaveChangesAsync();
        }

        // Removes given students from a given class. 
        public static async Task RemoveStudents([FromServices] PapersDbContext db, [FromBody] IEnumerable<Student> students, [FromRoute] Guid classId)
        {
            /// Possible optimisation: Alter this to only have to retrieve the students that are needed to remove. 
            /// Possible optimisation: Alter this to only receive ids instead of students. 
            // Gets the class. 
            Class? classToRemoveFrom = await db.Classes.Include(@class => @class.Students).FirstOrDefaultAsync(@class => @class.Id == classId);

            // If the class was not found, early return. 
            if (classToRemoveFrom is null)
            {
                return;
            }

            // Removes each student from the class. 
            foreach (Student student in students)
                classToRemoveFrom.Students.Remove(student);

            // Saves changes. 
            await db.SaveChangesAsync();
        }

        // Updates results from an array of new Paper Results
        // Tries to update the score for each paper result, if this fails at any point due to the paper result not existing, simply stops and returns before saving changes. 
        // If successful, returns HTTP 202
        public static async Task<IResult> UpdateResults([FromServices] PapersDbContext db, [FromBody] PaperResult[] results)
        {
            try
            {
                await results.ForEach(async result => (await db.PaperResults.FindAsync(result.Id) ?? throw new ArgumentException(JsonSerializer.Serialize(result))).Score = result.Score);
            }
            catch (ArgumentException e)
            {
                return Results.NotFound(e.Message);
            }
            finally
            {
                await db.SaveChangesAsync();
            }

            return Results.Accepted();
        }

        // Checks if a teacher's login information is valid and returns Success if they are. 
        public static async Task<IResult> ValidateTeacher([FromServices] User userInstance, [FromServices] UserValidator validator, [FromServices] PasswordHasher<string> hasher, [FromServices] PapersDbContext db, [FromBody] UserWithUnencryptedPassword user)
        {
            // Validates the given login details. 
            // If they are invalid then there is no need to query the database. 
            ValidationResult validationResult = await validator.ValidateAsync(user);

            if (!validationResult.IsValid)
            {
                Dictionary<string, string[]> errors = validationResult.Errors.ToDictionary();

                // logs and returns the errors as an HTTP 400
#if DEBUG
                Console.WriteLine(JsonSerializer.Serialize(errors));
#endif

                return Results.ValidationProblem(errors);
            }

            // Gets the teacher with a matching password or null if no teacher was found. 
            var queriedTeacher = await db.Teachers.Where(teacher => teacher.Name == user.Name)
                                               .Select(teacher => new { teacher.Id, user.Name, Password = PapersDbContext.SQLUtf8ToString(teacher.Password) })
                                               .AsAsyncEnumerable()
                                               .FirstOrDefaultAsync(teacher => (hasher.VerifyHashedPassword(teacher.Name, teacher.Password, user.Password) & (PasswordVerificationResult.Success | PasswordVerificationResult.SuccessRehashNeeded)) != 0);


            // If no teacher found, return HTTP 404. 
            if (queriedTeacher is null)
            {
                return Results.NotFound(user);
            }

            // Sets the details of the scoped user instance in the services part of the program. 
            userInstance.Id = queriedTeacher.Id;
            userInstance.Name = queriedTeacher.Name;
            userInstance.PasswordAsHex = queriedTeacher.Password;

            return Results.Ok(userInstance);
        }

        // Checks if a user's login information is valid and returns Success if they are. 
        public static async Task<IResult> ValidateUser<TUser>([FromServices] User userInstance, [FromServices] UserValidator validator, [FromServices] PasswordHasher<string> hasher, [FromServices] PapersDbContext db, [FromBody] UserWithUnencryptedPassword user) where TUser : User
        {
            // Validates the given login details. 
            // If they are invalid then there is no need to query the database. 
            ValidationResult validationResult = await validator.ValidateAsync(user);

            if (!validationResult.IsValid)
            {
                Dictionary<string, string[]> errors = validationResult.Errors.ToDictionary();

                // logs and returns the errors as an HTTP 400
#if DEBUG
                Console.WriteLine(JsonSerializer.Serialize(errors));
#endif

                return Results.ValidationProblem(errors);
            }

            // Gets the set to add to. 
            DbSet<TUser> userSet = GetSet<TUser>(typeof(TUser), db);

            // Gets the user with a matching password or null if no user was found. 
            var queriedUser = await userSet.Where(queryUser => queryUser.Name == user.Name)
                                               .Select(queryUser => new { queryUser.Id, queryUser.Name, Password = PapersDbContext.SQLUtf8ToString(queryUser.Password) })
                                               .AsAsyncEnumerable()
                                               .FirstOrDefaultAsync(queryUser => (hasher.VerifyHashedPassword(queryUser.Name, queryUser.Password, user.Password) & (PasswordVerificationResult.Success | PasswordVerificationResult.SuccessRehashNeeded)) != 0);
            // If no user found, return HTTP 404. 
            if (queriedUser is null)
            {
                return Results.NotFound(user);
            }

            // Sets the details of the scoped user instance in the services part of the program. 
            userInstance.Id = queriedUser.Id;
            userInstance.Name = queriedUser.Name;
            userInstance.PasswordAsHex = queriedUser.Password;

            return Results.Ok(userInstance);
        }
    }
}
```
=== ImageReader.cs
```cs
﻿using System.IO;
using Tesseract;
using System.Threading.Tasks;
using System;

namespace CourseworkPastPaperApplication2.Server
{
    // Class facade for the Tesseract OCR. 
    public class ImageReader
    {
        // Uses a cached TesseractEngine to save on memory. 
        private static readonly TesseractEngine ocr;
        // Since uses a cached engine, needs a boolean flag to keep track of whether or not the engine is currently in use. 
        private static bool isProcessing;

        // Initialises the cached engine with the tesseract data and english as the language. 
        static ImageReader()
        {
            string dataPath = """C:\Users\jeff1\source\repos\CourseworkPastPaperApplication2\Server\tessdata\""";
            ocr = new TesseractEngine(dataPath, "eng", EngineMode.Default);
        }

        // Reads the image and returns the string form. 
        public static async Task<string> ReadImage(byte[] imageBytes)
        {
            // Loads the image from memory. 
            using Pix image = Pix.LoadFromMemory(imageBytes);
         
            // Waits half a second until the engine is not in use to continue.
            // The half-second wait time is to avoid flooding the server with read instructions. 
            while (isProcessing)
            {
                await Task.Delay(TimeSpan.FromMilliseconds(500));
            }

            // sets the isProcessing boolean flag to indicate that the engine is in use and cannot be used. 
            isProcessing = true;
            string returnValue;
            // processes and reads the page. 
            using (Page page = ocr.Process(image))
            {
                returnValue = page.GetText();
            }
            
            // Indicates that the engine is free to use again and returns
            isProcessing = false;
            return returnValue;
        }

        // Runs the ReadImage function without blocking the thread so the server can do other things at the same time with that same thread. 
        public static async Task<string> ReadImageAsync(byte[] imageBytes)
        {
            return await Task.Run(() => ReadImage(imageBytes));
        }
    }
}

```
=== obj
==== Debug
===== net7.0
====== CourseworkPastPaperApplication2.Server.AssemblyInfo.cs
```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CourseworkPastPaperApplication2.Server")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("CourseworkPastPaperApplication2.Server")]
[assembly: System.Reflection.AssemblyTitleAttribute("CourseworkPastPaperApplication2.Server")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


```
====== CourseworkPastPaperApplication2.Server.GlobalUsings.g.cs
```cs
// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;

```
====== CourseworkPastPaperApplication2.Server.RazorAssemblyInfo.cs
```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ProvideApplicationPartFactoryAttribute("Microsoft.AspNetCore.Mvc.ApplicationParts.ConsolidatedAssemblyApplicationPartFact" +
    "ory, Microsoft.AspNetCore.Mvc.Razor")]

// Generated by the MSBuild WriteCodeFragment class.


```
====== ref
====== refint
====== staticwebassets
==== Release
===== net7.0
====== CourseworkPastPaperApplication2.Server.AssemblyInfo.cs
```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CourseworkPastPaperApplication2.Server")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("CourseworkPastPaperApplication2.Server")]
[assembly: System.Reflection.AssemblyTitleAttribute("CourseworkPastPaperApplication2.Server")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


```
====== CourseworkPastPaperApplication2.Server.GlobalUsings.g.cs
```cs
// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;

```
====== CourseworkPastPaperApplication2.Server.RazorAssemblyInfo.cs
```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ProvideApplicationPartFactoryAttribute("Microsoft.AspNetCore.Mvc.ApplicationParts.ConsolidatedAssemblyApplicationPartFact" +
    "ory, Microsoft.AspNetCore.Mvc.Razor")]

// Generated by the MSBuild WriteCodeFragment class.


```
====== ref
====== refint
====== staticwebassets
=== Pages
==== Error.cshtml.cs
```cs
﻿using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.Extensions.Logging;
using System.Diagnostics;

namespace CourseworkPastPaperApplication2.Server.Pages
{
    [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
    [IgnoreAntiforgeryToken]
    public class ErrorModel : PageModel
    {
        public string? RequestId { get; set; }

        public bool ShowRequestId => !string.IsNullOrEmpty(RequestId);

        private readonly ILogger<ErrorModel> _logger;

        public ErrorModel(ILogger<ErrorModel> logger)
        {
            _logger = logger;
        }

        public void OnGet()
        {
            RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier;
        }
    }
}
```
=== Program.cs
```cs
//using CourseworkPastPaperApplication.Shared;
using CourseworkPastPaperApplication2.Server;
using CourseworkPastPaperApplication2.Shared;
using FluentValidation;
using FluentValidation.Results;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;

namespace CourseworkPastPaperApplication2
{
    public class Program
    {
        /// This code checks if the program is being compiled in debug mode, if it is, instantiates a Faker object used for filling the database with fake data. 
#if DEBUG
        private static readonly Bogus.Faker faker = new Bogus.Faker();
#endif
        // Entry-point for the Server
        public static void Main(string[] args)
        {
            var builder = WebApplication.CreateBuilder(args);

            // Adds services to the container.
            // Generic boilerplate services to add. 
            builder.Services.AddControllersWithViews();
            builder.Services.AddRazorPages();

            // Adds the database facade. 
            builder.Services.AddDbContext<PapersDbContext>(optionsAction: options =>
            {
                // If compiled in debug mode, adds extra logging which would normally slow down the program so is not used for Release mode. 
                // builder.Configuration.GetConnectionString returns the connection string of the database via the specified key (parameter) from the AppSettings.json file. 
#if DEBUG
                options.UseNpgsql(builder.Configuration.GetConnectionString("WebAPIDatabaseWithErrorDetail"));
                options.EnableSensitiveDataLogging()
                       .EnableDetailedErrors();
#else
                options.UseNpgsql(builder.Configuration.GetConnectionString("WebAPIDatabase"));
#endif
            });

            // AddScoped adds a new instance per used. 
            // Adds a new PasswordHasher which is used by the program to hash and verify passwords, string parameter is since the username is used to hash the password
            builder.Services.AddScoped<PasswordHasher<string>>();
            // User validation service. 
            builder.Services.AddScoped<UserValidator>();
            // Adds a user service which keeps track of a user. This is not used everywhere since it is preferred to place workload on the client instead of the server. 
            builder.Services.AddScoped<User>(x => new Teacher());

            // Configures the HttpJsonOptions to follow standard naming conventions. 
            builder.Services.ConfigureHttpJsonOptions(options =>
            {
                options.SerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;
                options.SerializerOptions.PropertyNameCaseInsensitive = true;
            });

            // Adds logging
            if (builder.Environment.IsDevelopment())
            {
                builder.Logging.AddConsole();
                builder.Services.AddLogging();
            }

            var app = builder.Build();

            // Configure the HTTP request pipeline.
            ConfigureHttp(app);

            app.UseHttpsRedirection();

            // Adds necessary files for Blazor
            app.UseBlazorFrameworkFiles();
            // Adds static files to be used in the program. 
            app.UseStaticFiles();

            app.UseRouting();

            app.MapRazorPages();
            app.MapControllers();
            app.MapFallbackToFile("index.html");

            // Maps all endpoints, for the incoming request to the function to be executed. 
            MapEndpoints(app);

            // Runs the app and blocks the thread until the app stops running. 
            app.Run();

            static void ConfigureHttp(WebApplication app)
            {
                if (!app.Environment.IsDevelopment())
                {
                    app.UseExceptionHandler("/Error");
                    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                    app.UseHsts();

                    return;
                }

                // Allows for breakpoints and better debugging if in debug mode. 
                app.UseWebAssemblyDebugging();

                // This method logs all incoming requests to the server as well as some information about them. 
                app.Use(async (context, next) =>
                {
                    // Log incoming request
                    app.Logger.LogInformation($"Incoming request: {context.Request.Method} {context.Request.Path}");

                    // Call the next middleware in the pipeline
                    await next.Invoke();

                    // Log outgoing response
                    app.Logger.LogInformation($"Outgoing response: {context.Response.StatusCode}");
                });
            }
        }

        private static void MapEndpoints(WebApplication app)
        {
#if DEBUG
            MapDebugEndpoints(app);
#endif
            // Maps endpoints corresponding to the given subject
            // E.g. MapClassEndpoints maps all endpoints relating to retrieving, updating, etc. classes. 
            MapLoginEndpoints(app);
            MapSignUpEndpoints(app);
            MapStudentEndpoints(app);
            MapTeacherEndpoints(app);
            MapClassEndpoints(app);
            MapQuestionEndpoints(app);
            MapAssignmentEndpoints(app);
            MapPaperResultEndpoints(app);
        }

        private static void MapPaperResultEndpoints(WebApplication app)
        {
            app.MapPut("/PaperResult/Results", EndpointFunctions.UpdateResults);
        }

        private static void MapAssignmentEndpoints(WebApplication app)
        {
            app.MapGet("/Assignment/{assignmentId:guid}/Withh/", EndpointFunctions.GetAssignmentWith);

            app.MapGet("/Assignment/{assignmentId:guid}", EndpointFunctions.GetAssignment);

            app.MapDelete("/Assignment/{assignmentId:guid}", EndpointFunctions.RemoveAssignment);

            app.MapGet("/Assignment/{assignmentId:guid}/Results", EndpointFunctions.GetAssignmentResults);

            app.MapGet("/Assignment/{assignmentId}/Student/{studentId}/Result", EndpointFunctions.GetPaperResultsForSpecificStudentAssignment);
        }

        private static void MapQuestionEndpoints(WebApplication app)
        {
            app.MapPut("/Image", EndpointFunctions.ReadInImageFile);

            app.MapGet("/Options", EndpointFunctions.GetRadioOptions);

            app.MapPost("/Question", EndpointFunctions.GetQuestionsWithFilters);
        }

        private static void MapClassEndpoints(WebApplication app)
        {
            app.MapPost("/Class/{classId:guid}/Remove", EndpointFunctions.RemoveStudents);

            app.MapDelete("/Class/{classId:guid}", EndpointFunctions.RemoveClass);

            app.MapGet("/Classs/{classId:guid}/Students", EndpointFunctions.GetStudentsInClass);

            app.MapPost("/Class/{classId:guid}/Add", EndpointFunctions.AddStudentsToClass);

            app.MapGet("/Class/{classId:guid}/Assignments", EndpointFunctions.GetClassAssignments);

            app.MapPost("/Class/{classId:guid}/Assignments", EndpointFunctions.AddAssignmentToClass);
        }

        private static void MapTeacherEndpoints(WebApplication app)
        {
            app.MapGet("/Teacher/{teacherId:guid}/Classes", EndpointFunctions.GetTeacherClasses);
            app.MapPut("/Teacher/{teacherId:guid}/Classes", EndpointFunctions.AddTeacherClass);
        }

        private static void MapStudentEndpoints(WebApplication app)
        {
            app.MapGet("/Student/SoundsLike/{username}", EndpointFunctions.GetSoundsLike);
        }

        private static void MapSignUpEndpoints(WebApplication app)
        {
            app.MapPost("/SignUpTeacher", EndpointFunctions.SignUp<Teacher>);

            app.MapPost("/SignUpStudent", EndpointFunctions.SignUp<Student>);
        }

        private static void MapLoginEndpoints(WebApplication app)
        {
            app.MapPost("/ValidateTeacher", EndpointFunctions.ValidateUser<Teacher>);

            app.MapPost("/ValidateStudent", EndpointFunctions.ValidateUser<Student>);
        }

        // Maps all endpoints used in the debug build of the app, used for debugging and filling the database with fake data, etc. 
        private static void MapDebugEndpoints(WebApplication app)
        {
            // Endpoint to get all teachers
            app.MapGet("/Teachers", ([FromServices] PapersDbContext db) => db.Teachers)
                            .WithName("GetAllTeachers");

            // Get teacher with specific name
            app.MapGet("/Teachers/{name}", ([FromServices] PapersDbContext db, [FromRoute] string name) => from teacher in db.Teachers
                                                                                                           where teacher.Name == name
                                                                                                           select teacher);
            // Get all students
            app.MapGet("/Students", ([FromServices] PapersDbContext db) => db.Students)
                .WithName("GetAllStudents");

            // Get student with specific name
            app.MapGet("/Students/{name}", ([FromServices] PapersDbContext db, [FromRoute] string name) => from student in db.Students
                                                                                                           where student.Name == name
                                                                                                           select student);
            // Get students of teacher with specific name for teacher
            app.MapGet("/Teachers/{name}/Students", ([FromServices] PapersDbContext db, [FromRoute] string name) => db.Teachers.Where(teacher => teacher.Name == name)
                                                                                                                               .Select(teacher => teacher.Classes
                                                                                                                               .Select(@class => @class.Students)));
            // Gets all classes
            app.MapGet("/Classes", async ([FromServices] PapersDbContext db) =>
            {
                Microsoft.EntityFrameworkCore.Query.IIncludableQueryable<Class, ICollection<Student>> includableQueryable = db.Classes.Include(@class => @class.TeacherNavigation).Include(@class => @class.Students);

                await db.SaveChangesAsync();

                IEnumerable<Class> classes = JsonSerializer.Deserialize<IEnumerable<Class>>(JsonSerializer.Serialize(includableQueryable))!;

                Console.WriteLine(JsonSerializer.Serialize(includableQueryable));
                Console.WriteLine("DATA: " + JsonSerializer.Serialize(classes.Select(@class => @class.Students)));

                return includableQueryable;
            })
            .WithName("GetAllClasses");

            app.MapGet("/Assignments", ([FromServices] PapersDbContext db) => db.Assignments.Include(x => x.Questions));
            
            // This HTTP-GET method will fill the database with 1 class of 4 students and 1 teacher, generated by Faker then returns all teachers.
            app.MapGet("/FakeData", ([FromServices] PapersDbContext db) =>
            {
                Console.WriteLine("Faking data...");

                Teacher teacher = new Teacher { Name = faker.Name.FullName(), Password = faker.Random.Bytes(32) };
                Class @class = new Class { Id = Guid.NewGuid(), TeacherNavigation = teacher };

                teacher.Classes.Add(@class);

                List<Student> students = new List<Student>
                {
                    new Student { Name = faker.Name.FullName(), Password = faker.Random.Bytes(32) },
                    new Student { Name = faker.Name.FullName(), Password = faker.Random.Bytes(32) },
                    new Student { Name = faker.Name.FullName(), Password = faker.Random.Bytes(32) }
                };

                students.ForEach(st => @class.Students.Add(st));

                db.Teachers.Add(teacher);
                db.Classes.Add(@class);
                db.Students.AddRange(students);

                db.SaveChanges();
            });

            // Clears the database by executing a TRUNCATE statement for each table. 
            app.MapGet("/Clear", ([FromServices] PapersDbContext db) =>
            {
                IEnumerable<string> tables = from type in db.Model.GetEntityTypes()
                                             select type.GetTableName();

                foreach (string table in tables.Distinct())
                {
                    db.Database.ExecuteSqlRaw($"""TRUNCATE TABLE {db.Model.GetDefaultSchema()}."{table}" CASCADE;""");
                }

                db.SaveChanges();
            });
        }
    }
}
```
=== Properties
=== tessdata
=== UserValidator.cs
```cs
﻿using CourseworkPastPaperApplication2.Shared;
using FluentValidation;
using System.Linq;
using System.Collections.Generic;

namespace CourseworkPastPaperApplication2.Server
{
    // This class is used for validating users' usernames and passwords. 
    // This class inherits from the AbstractValidator class which is supplied by the FluentValidation package that allows for terse and functional definitions for validation rules. 
    public class UserValidator : AbstractValidator<UserWithUnencryptedPassword>
    {
        // The set of all valid characters. 
        // The property accessors allow it to be retreieved but only initialised, making it a readonly property. 
        // The IReadOnlySet<char> is an interface, this allows for polymorphism without the constraints of inheritance. 
        private IReadOnlySet<char> validPasswordChars { get; init; }

        public UserValidator()
        {
            // Uses a singleton (class for which there can be only a single instance) to keep track of all valid passwords. 
            // A singleton is used to save on memory. 
            // If demand grew then this could be refactored to use a pool of password sets and use whichever is not currently in use. 
            // As it stands, this is not a necessity. 
            validPasswordChars = ValidCharsHashSetSingleton.GetInstance();

            // Each of these validation rules has an associated error message that will be returned if the validation rule fails. 

            // Defines validation rules for the username. 
            // These rules state that the username must not be null and must be between 6 and 48 characters in length (inclusive). 
            const int UsernameMinimumLength = 6;
            const int UsernameMaximumLength = 48;
            RuleFor(user => user.Name).NotNull()
                                      .MinimumLength(UsernameMinimumLength).WithMessage($"Username was too short. Minimum length {UsernameMinimumLength}.")
                                      .MaximumLength(UsernameMaximumLength).WithMessage($"Username was too long. Maximum length {UsernameMaximumLength}.");

            // Defines validation rules for the password. 
            // These rules state that the password must not be null and must be between 12 and 60 characters in length (inclusive) and that each character must be contained within the set of valid characters. 
            const int PasswordMinimumLength = 12;
            const int PasswordMaximumLength = 60;
            RuleFor(user => user.Password).NotNull()
                                          .MinimumLength(PasswordMinimumLength).WithMessage($"Password was too short. Minimum length {PasswordMinimumLength}.")
                                          .MaximumLength(PasswordMaximumLength).WithMessage($"Password was too long. Maximum length {PasswordMaximumLength}.")
                                          .Must(pass => pass.All(validPasswordChars.Contains)).WithMessage($"Cam only have alphanumeric characters and the following symbols: '{string.Concat(validPasswordChars.Where(c => !char.IsAsciiLetterOrDigit(c)))}'");
        }
    }

    // Singleton containing all the valid characters. 
    // This inherits from the HashSet class which uses hashing to create a collection of distinct values and O(1) lookup times for checking if a value is contained within the set. 
    public class ValidCharsHashSetSingleton : HashSet<char>
    {
        // All valid characters for the password. 
        private const string ValidPasswordCharacters = """abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 "~`!@#$%^&*()_-+={}[]|\:;'<,>.?/""";

        // Instance of the class, warning disabled for compilation purposes. 
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        private static ValidCharsHashSetSingleton instance;
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

        // Delegate that handles the getting of an instance. 
        // At the start, this is set to a function that will both set the instance and get it. 
        // Later, this is set to a function that will only return the instance. 
        // This uses the idea that functions are first-class objects and so can be reassigned freely. 
        // The property accessor for setting this is made private to prevent it from being assigned to from without. 
        public static InstanceGetter GetInstance { get; private set; } = GetAndSetInstance;

        // Definition for the delegate type that GetInstance is of. 
        // This states that InstanceGetter will be a function that will return a ValidCharsHashSetSingleton. 
        public delegate ValidCharsHashSetSingleton InstanceGetter();

        // This sets the instance to be a new instance of the class and fills it with the characters it checks for. 
        private static ValidCharsHashSetSingleton GetAndSetInstance()
        {
            instance = new ValidCharsHashSetSingleton();

            foreach (char character in ValidPasswordCharacters)
            {
                instance.Add(character);
            }

            GetInstance = OnlyGetInstance;

            return instance;
        }

        // This returns the instance only. 
        private static ValidCharsHashSetSingleton OnlyGetInstance()
        {
            return instance;
        }

        // Private constructor preventing this class from being instantiated without the GetInstance method. 
        private ValidCharsHashSetSingleton()
        {
        }
    }
}

```
== Shared
=== bin
==== Debug
===== net7.0
==== Release
===== net7.0
=== Checked.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CourseworkPastPaperApplication2.Shared
{
    // Simple class used for Checkboxes to represent both the value and the state of the checkbox. 
    public class Checked<T>
    {
        public T Value { get; init; } = default!;
        public bool IsChecked { get; set; } = false;

        // Implicit converters between the value, two-way. 
        public static implicit operator Checked<T>(T value) => new Checked<T> { Value = value, IsChecked = false };
        public static implicit operator T(Checked<T> value) => value.Value;
    }
}
```
=== CourseworkPastPaperApplication2.Shared.csproj
```cs
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="FluentValidation" Version="11.5.2" />
    <PackageReference Include="Microsoft.AspNetCore.Components.Web" Version="7.0.5" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="7.0.5" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="7.0.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Relational" Version="7.0.5" />
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="7.0.3" />
  </ItemGroup>

  <ItemGroup>
    <SupportedPlatform Include="browser" />
  </ItemGroup>
</Project>

```
=== Extensions.cs
```cs
﻿using FluentValidation.Results;
using Microsoft.AspNetCore.Components.Forms;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace CourseworkPastPaperApplication2.Shared
{
    // C# has a feature called extension methods which allow for a class to be provided with additional methods based on their public properties. 
    // This class is a static class used as a library of all those extensions used across this application. 
    public static class Extensions
    {
        // Returns an enumerable with its index attached as a tuple, inspired by the usefulness of Python's enumerate function. 
        // The indexToStartAt parameter indicates to start enumerating from a given index and also have a matching index returned. 
        public static IEnumerable<(int, T)> WithIndex<T>(this IEnumerable<T> values, int indexToStartAt = 0) => values.Skip(indexToStartAt).Select((value, i) => (i + indexToStartAt, value));

        // Converts an IBrowserFile to a Data URL to be displayed in the browser. 
        public static async Task<string> ToDataUrlAsync(this IBrowserFile image)
        {
            // Creates a memory stream and copies the image to that stream. 
            /// Could be optimised to avoid unnecessary allocations
            using var reader = new MemoryStream();

            await image.OpenReadStream().CopyToAsync(reader);

            // Converts the image to base64 then performs the necessary concatenations to convert it into a valid data URL. 
            string base64Image = Convert.ToBase64String(reader.ToArray());

            return $"""data:{image.ContentType};base64,{base64Image}""";
        }

        // Converts an image to a data URL via its Data property and FileName property. 
        public static string ToDataUrl(this Question question)
        {
            // Converts the image data to base 64. 
            string base64Image = Convert.ToBase64String(question.Data);

            // Gets the extension then cuts off the '.' at the start of the extension. 
            // Performs the necessary concatenations to create a Data URL. 
            return $"""data:image/{Path.GetExtension(question.FileName.AsSpan()).Slice(1)};base64,{base64Image}""";
        }

        // Enumerates through values and applies an action to each one as a more terse and function-based alternative to the standard foreach (var item in values) syntax. 
        public static void ForEach<T>(this IEnumerable<T> values, Action<T> action)
        {
            // Loops through each value and applies the given subroutine to each value. 
            foreach (T value in values)
            {
                action.Invoke(value);
            }
        }

        // Same as ForEach except also provides an index. 
        public static void ForEach<T>(this IEnumerable<T> values, Action<T, int> action)
        {
            foreach (var (index, value) in values.WithIndex())
            {
                action.Invoke(value, index);
            }
        }

        // ForEach for asynchronous subroutines. 
        public static async Task ForEach<T>(this IEnumerable<T> values, Func<T, Task> action)
        {
            foreach (T value in values)
            {
                await action.Invoke(value);
            }
        }

        // Async ForEach with index also. 
        public static async Task ForEach<T>(this IEnumerable<T> values, Func<T, int, Task> action)
        {
            foreach (var (index, value) in values.WithIndex())
            {
                await action.Invoke(value, index);
            }
        }

        // Gets the row at index rowIndex, useful for extracting a row from an array of arrays etc. 
        public static IEnumerable<T> GetRow<T>(this IEnumerable<IEnumerable<T>> values, int rowIndex)
        {
            return values.Skip(rowIndex).First();
        }

        
        // Gets the column at columnIndex, useful for extracting a column from an array of arrays etc. 
        public static IEnumerable<T> GetColumn<T>(this IEnumerable<IEnumerable<T>> values, int columnIndex)
        {
            foreach (IEnumerable<T> enumerable in values)
            {
                if (enumerable.FirstOrDefault() is T value)
                {
                    yield return value;
                }
            }
        }
        
        // Gets all rows but the one indicated by rowIndex
        public static IEnumerable<IEnumerable<T>> SkipRow<T>(this T[][] array, int rowIndex)
        {
            int rowCount = array.Length;
            int columnCount = array[0].Length;

            for (int i = 0; i < rowCount; i++)
            {
                if (i == rowIndex)
                    continue;

                yield return buildRow(array, columnCount, i);
            }

            // Local function used to build a row
            // Simply enumerates through and returns all values of the row as indicated by the index, i. 
            static IEnumerable<T> buildRow(T[][] array, int columnCount, int i)
            {
                for (int j = 0; j < columnCount; j++)
                {
                    yield return array[i][j];
                }
            }
        }

        // Gets all columns but the one indicated by columnIndex
        public static IEnumerable<IEnumerable<T>> SkipColumn<T>(this T[][] array, int columnIndex)
        {
            int rowCount = array.Length;
            int columnCount = array[0].Length;

            for (int i = 0; i < rowCount; i++)
            {
                if (i == columnIndex)
                    continue;

                yield return buildColumn(array, columnCount, i);
            }

            // Local function used to build a column
            // Simply enumerates through and returns all values of the column as indicated by the index, i. 
            static IEnumerable<T> buildColumn(T[][] array, int columnCount, int i)
            {
                for (int j = 0; j < columnCount; j++)
                {
                    yield return array[j][i];
                }
            }
        }

        // Splits a collection of values into two separate enumerables with one up to a given index and the other from the given index onwards.
        // The second group of values is returned via the out parameters, restOfValues. 
        public static IEnumerable<T> IndexedPartition<T>(this IEnumerable<T> values, int partitionIndex, out IEnumerable<T> restOfValues)
        {
            // The `using` keyword specifies that this variable is to be disposed of when it goes out of scope, similar to Python's context manager (`with`) syntax. 
            using var enumerator = values.GetEnumerator();

            // Function to get all values up to the partitionIndex
            var upTo = GetUpToIndex(enumerator, partitionIndex);

            // Gets all the rest of the values. 
            restOfValues = enumerator.ToEnumerable();

            return upTo;
        }

        // Converts an IEnumerator to an IEnumerable. 
        public static IEnumerable<T> ToEnumerable<T>(this IEnumerator<T> values)
        {
            // Continues looping until there are no more values. 
            while (values.MoveNext())
            {
                // Yields each value. 
                yield return values.Current;
            }
        }

        // Gets all values from an IEnumerator until partitionIndex. 
        private static IEnumerable<T> GetUpToIndex<T>(IEnumerator<T> enumerator, int partitionIndex)
        {
            // post-decrements partitionIndex once per loop and checks if it is greater or equal to 0. 
            // In layman's terms, this counts down until partitionIndex = 0. 
            while (partitionIndex-- >= 0)
            {
                // Ensures there are still values to enumerate through (that partitionIndex is not greater than the length of the collection of values)
                bool sequenceContinues = enumerator.MoveNext();

                // Throws if the aforementioned error occurs. 
                if (!sequenceContinues)
                {
                    throw new ArgumentOutOfRangeException(nameof(partitionIndex));
                }

                yield return enumerator.Current;
            }
        }
        
        // Custom JSON deserialisation functions. 
        public static T Deserialize<T>(this string jsonString) where T : new()
        {
            return (T)jsonString.Deserialize(typeof(T));
        }

        public static object Deserialize(this string jsonString, Type type)
        {
            // Parses the jsonString into a new JsonDocument. 
            var document = JsonDocument.Parse(jsonString);
            
            // Checks if value can be parsed then tries to parse it. 
            if (type.GetMethod("Parse", new Type[] { typeof(string) }) is MethodInfo info)
            {
                try
                {
                    return info.Invoke(null, new object[] { jsonString })!;
                }
                // Empty catch to skip to next part if parsing fails. 
                catch
                {

                }
            }

            // Checks if is JSON primitive type and deserialises based on that. 
            if (type.IsPrimitive || type == typeof(string) || type == typeof(byte[]) || type == typeof(Guid))
            {
                return document.RootElement.Deserialize(type)!;
            }
            
            // If an array, loops through the JSON values, deserialises them, and adds them to a list then returns that list. 
            if (type.IsArray)
            {
                System.Collections.ArrayList values = new System.Collections.ArrayList();

                foreach (var item in document.RootElement.EnumerateArray())
                {
                    values.Add(item.GetRawText().Deserialize(type.GetElementType()!));
                }
                Array array = Array.CreateInstance(type.GetElementType()!, values.Count);
                values.CopyTo(array);
                return array;
            }

            // Ensures that the type has a blank constructor to instantiate with. 
            object value = type.GetConstructor(Type.EmptyTypes)?.Invoke(null) ?? throw new SerializationException($"Must contain a blank constructor: {type.FullName}");

            // Loops through each property using reflection (only the properties that can be used and have not been specified to not be serialised with the JsonIgnoreAttribute also where it is not an indexer as those should not be deserialised or serialised. 
            foreach (var property in type.GetProperties().Where(property => property.CanRead && property.CanWrite && property.GetCustomAttribute(typeof(JsonIgnoreAttribute)) is null).Where(property => !property.GetIndexParameters().Any()))
            {
                // Tries to set a value onto the new object or sets it to null (error only thrown when JSON value is null)
                try
                {
                    property.SetValue(value, document.RootElement.TryGetProperty(JsonNamingPolicy.CamelCase.ConvertName(property.Name), out JsonElement element) ? element.GetRawText().Deserialize(property.PropertyType) : null);
                }
                catch (Exception e)
                {
                    property.SetValue(value, null);
#if DEBUG
                    Console.WriteLine(e.Message);
#endif
                }
            }

            return value;
        }

        // Function to add multiple values in one go. 
        public static void AddRange<T>(this ICollection<T> values, IEnumerable<T> valuesToAdd) => valuesToAdd.ForEach(values.Add);

        // Function to convert a list of validation errors to a dictionary, mapping the name of the property for which the validation error occurred on to the array of validation errors. 
        public static Dictionary<string, string[]> ToDictionary(this List<ValidationFailure> errors)
        {
            var result = new Dictionary<string, List<string>>();

            // Loops through each error and adds it to the dictionary
            // Also adds the property name if not already present in the dictionary
            foreach (ValidationFailure error in errors)
            {
                if (result.TryAdd(error.PropertyName, new List<string>() { error.ErrorMessage }))
                {
                    continue;
                }

                result[error.PropertyName].Add(error.ErrorMessage);
            }

            // Converts each list to an array, to match with what is required by certain third-party services. 
            return result.ToDictionary(
                keyValuePair => keyValuePair.Key,
                keyValuePair => keyValuePair.Value.ToArray()
                );
        }
    }
}

```
=== Models
==== Assignment.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace CourseworkPastPaperApplication2.Shared;

// Class representing the Assignment table
// Names of properties indicate the field they represent except from for the collections which are representing any one-to-many/many-to-many links or properties not using the { get; set; } syntax as those are simply used for easier functionality in the class. 
public class Assignment : DbTable
{
    public DateOnly Set { get; set; }

    public DateOnly Due { get; set; }

    public string Name { get; set; } = null!;

    [JsonInclude]
    public int TotalMarks => Questions.Sum(question => question.Marks);

    [JsonInclude]
    public virtual ICollection<Question> Questions { get; set; } = new List<Question>();

    [JsonIgnore]
    public virtual Class Class { get; set; } = null!;
}
```
==== Class.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace CourseworkPastPaperApplication2.Shared;

// Class representing the Class table
// Names of properties indicate the field they represent except from for the collections which are representing any one-to-many/many-to-many links or properties not using the { get; set; } syntax as those are simply used for easier functionality in the class. 
public class Class : DbTable
{
    public Guid TeacherId { get; set; }

    public string Name { get; set; } = null!;

    public virtual Teacher TeacherNavigation { get; set; } = null!;

    public virtual ICollection<Student> Students { get; init; } = new List<Student>();

    public virtual ICollection<Assignment> Assignments { get; init; } = new List<Assignment>();
}

```
==== CourseworkDatabaseContext.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore.Query;
using Microsoft.EntityFrameworkCore.Query.SqlExpressions;
using Npgsql.EntityFrameworkCore.PostgreSQL;
using Npgsql.EntityFrameworkCore.PostgreSQL.Query.Expressions.Internal;

namespace CourseworkPastPaperApplication2.Shared;

// This class is a facade over the database and provides functionality for querying, modifying, etc. 
// This is largely provider independent to allow for swapping to other SQL (or even No-SQL) providers with minimal changes required. 
public class PapersDbContext : DbContext
{
    public PapersDbContext()
    {
    }

    // Initialises with database initialisation options. 
    public PapersDbContext(DbContextOptions<PapersDbContext> options)
        : base(options)
    {
    }

    // Links to a custom SQL function that converts UTF8 bytes to a string. 
    [DbFunction("utf8_to_string")]
    public static string SQLUtf8ToString(byte[] bytes)
    {
        return Encoding.UTF8.GetString(bytes);
    }

    // Links to a builtin SQL function that retrieves the Soundex (phonic representation) of a string. 
    // Does not return anything in the C# code since this should only be used in SQL queries. 
    [DbFunction("soundex", IsBuiltIn = true)]
    public static string Soundex(string argument) => throw new InvalidOperationException(nameof(Soundex));

    // Each DbSet<{T}> represents the table, {T}
    public virtual DbSet<Assignment> Assignments { get; set; }

    public virtual DbSet<Class> Classes { get; set; }

    public virtual DbSet<PaperResult> PaperResults { get; set; }

    public virtual DbSet<Question> Questions { get; set; }

    public virtual DbSet<Student> Students { get; set; }

    public virtual DbSet<Teacher> Teachers { get; set; }

    public virtual DbSet<ExamBoard> ExamBoards { get; set; }

    public virtual DbSet<Level> Levels { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) => optionsBuilder.UseNpgsql("Host=localhost;Database=CourseworkDatabase;Username=postgres;Password=oneplustwoequalsthreeoneplustwoequalsthree;Include Error Detail=true");

    // Builds the facades internal representation of the database to allow it to correctly transform queries to the database. 
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Specifies the schema of the database. 
        modelBuilder.HasDefaultSchema("public");

        // Adds the fuzzystrmatch extension to the database which contains the Soundex function. 
        modelBuilder.HasPostgresExtension("fuzzystrmatch");

        // Configures the Student entity. 
        modelBuilder.Entity<Student>(student =>
        {
            // Indicates that Id is used as both a key and an index. 
            student.HasIndex(st => st.Id);
            student.HasKey(st => st.Id);

            // Lists the properties of Student. 
            student.Property(st => st.Name);
            student.Property(st => st.Password);

            // Indicates to ignore the PasswordAsHex property. 
            student.Ignore(st => st.PasswordAsHex);

            // Indicates a many-to-many relation between students and classes. 
            student.HasMany(st => st.CurrentClasses).WithMany(@class => @class.Students);
            // Indicates a one-to-many relation between students and paper results with paper results having a key of StudentId
            student.HasMany(st => st.PaperResults).WithOne(p => p.Student).HasForeignKey(p => p.StudentId);
        });

        // Configures the Teacher entity. 
        modelBuilder.Entity<Teacher>(teacher =>
        {
            // Indicates that Id is used as both a key and an index. 
            teacher.HasIndex(teacher => teacher.Id);
            teacher.HasKey(teacher => teacher.Id);

            // Lists the properties of Teacher. 
            teacher.Property(teacher => teacher.Name);
            teacher.Property(teacher => teacher.Password);

            // Indicates to ignore the PasswordAsHex property. 
            teacher.Ignore(st => st.PasswordAsHex);

            // Indicates a one-to-many relation with classes. 
            teacher.HasMany(teacher => teacher.Classes).WithOne(@class => @class.TeacherNavigation);
        });

        // Configures the Class entity. 
        modelBuilder.Entity<Class>(@class =>
        {
            // Indicates that Id is used as both a key and an index. 
            @class.HasIndex(cl => cl.Id);
            @class.HasKey(cl => cl.Id);

            // Shows the property of Class. 
            @class.Property(cl => cl.Name);

            // Configures Class to have a many-to-one relation with Teacher with a foreign key of TeacherId
            @class.HasOne(cl => cl.TeacherNavigation).WithMany(teacher => teacher.Classes).HasForeignKey(cl => cl.TeacherId);
            // Configures Class to have a many-to-many relation with Student
            @class.HasMany(cl => cl.Students).WithMany(st => st.CurrentClasses);

            // Configures  Class to have a one-to-many relation with Assignment
            @class.HasMany(cl => cl.Assignments).WithOne(a => a.Class);
        });

        // Configures the Assignment entity. 
        modelBuilder.Entity<Assignment>(assignment =>
        {
            // Indicates that Id is used as both a key and an index. 
            assignment.HasIndex(a => a.Id);
            assignment.HasKey(a => a.Id);

            // Lists the properties of Assignment. 
            assignment.Property(a => a.Due);
            assignment.Property(a => a.Set);
            assignment.Property(a => a.Name);

            // Configures Assignment to have a many-to-many relation with Question with the Question class having no navigation collection property. 
            // That decision was based off of the lack of need for such a property. 
            assignment.HasMany(a => a.Questions).WithMany();

            // Configures Assignment to have a many-to-one relation with Class
            assignment.HasOne(a => a.Class).WithMany(cl => cl.Assignments);
        });

        // Configures the PaperResult entity. 
        modelBuilder.Entity<PaperResult>(paperResult =>
        {
            // Indicates that Id is used as both a key and an index. 
            paperResult.HasIndex(p => p.Id);
            paperResult.HasKey(p => p.Id);

            // Shows the property of Class. 
            paperResult.Property(p => p.Score);

            // Indicates that PaperResult has a many-to-one relation with Student with a foreign key of StudentId
            paperResult.HasOne(p => p.Student).WithMany(st => st.PaperResults).HasForeignKey(p => p.StudentId);
            // Indicates that PaperResult has a many-to-one relation with Assignment with a foreign key of AssignmentId
            paperResult.HasOne(p => p.Assignment).WithMany().HasForeignKey(p => p.AssignmentId);
        });

        // Configures the Question entity. 
        modelBuilder.Entity<Question>(question =>
        {
            // Indicates that Id is used as both a key and an index. 
            question.HasIndex(q => q.Id);
            question.HasKey(q => q.Id);

            // Lists the properties of Question. 
            question.Property(q => q.Data);
            question.Property(q => q.ReadData);
            question.Property(q => q.FileName);
            question.Property(q => q.Marks);

            // Configures an optional many-to-one relation with the filter options (separately)
            question.HasOne(q => q.Level).WithMany().IsRequired(false);
            question.HasOne(q => q.ExamBoard).WithMany().IsRequired(false);
        });

        // Configures the ExamBoard and Level entities. 
        modelBuilder.Entity<ExamBoard>(SetUpFilterOptions);
        modelBuilder.Entity<Level>(SetUpFilterOptions);
    }

    // Configures Filter Option entities. 
    private static void SetUpFilterOptions<T>(EntityTypeBuilder<T> filterOption) where T : class, IFilterOption
    {
        // Indicates that Id is used as both a key and an index. 
        filterOption.HasIndex(option => option.Id);
        filterOption.HasKey(option => option.Id);

        // Configures the Name property of the filter options.
        filterOption.Property(option => option.Name);
    }
}
```
==== DbTable.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CourseworkPastPaperApplication2.Shared
{
    // Abstract base class from which all classes which represent table (except for Level and ExamBoard since they are smaller tables). 
    public abstract class DbTable
    {
        // Each has its own ID. 
        public Guid Id { get; set; } = Guid.NewGuid();

        // The hash code of each object is only the ID's hashcode to allow different instances of the same class representing the same record within the database to work with hash sets and other hashing operations since the ID is guaranteed constant for each record. 
        public override int GetHashCode()
        {
            return Id.GetHashCode();
        }

        // Overides the equality functions to work solely off of their IDs to avoid reference checking equality comparisons. . 
        public override bool Equals(object? obj) => obj switch
        {
            DbTable table => table == this,
            _ => base.Equals(obj)
        };

        public static bool operator ==(DbTable left, DbTable right) => left.Id == right.Id;

        public static bool operator !=(DbTable left, DbTable right) => left.Id != right.Id;
    }
}

```
==== PaperResult.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace CourseworkPastPaperApplication2.Shared;

// Class representing the PaperResult table
// Names of properties indicate the field they represent except from for the collections which are representing any one-to-many/many-to-many links or properties not using the { get; set; } syntax as those are simply used for easier functionality in the class. 
public class PaperResult : DbTable
{
    public int Score { get; set; }

    public Guid AssignmentId { get; set; }

    public Guid StudentId { get; set; }

    public Guid QuestionId { get; set; }

    [JsonIgnore]
    public virtual Assignment Assignment { get; set; } = null!;

    public virtual Question Question { get; set; } = null!;

    [JsonIgnore]
    public virtual Student Student { get; set; } = null!;
}

```
==== Question.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace CourseworkPastPaperApplication2.Shared;

// Class representing the Question table
// Names of properties indicate the field they represent except from for the collections which are representing any one-to-many/many-to-many links or properties not using the { get; set; } syntax as those are simply used for easier functionality in the class. 
public class Question : DbTable
{
    public string FileName { get; set; } = null!;

    public int Marks { get; set; }

    public byte[] Data { get; set; } = null!;

    public string ReadData { get; set; } = null!;

    public ExamBoard? ExamBoard { get; set; } = null!;

    public Level? Level { get; set; } = null!;
}
```
==== QuestionSearchFilterOptions.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace CourseworkPastPaperApplication2.Shared
{
    // Record containing a list of levels and of exam boards. 
    public record RadioOptions(Level[] Levels, ExamBoard[] ExamBoards);

    // Level class that represents the Level table
    // TypeConverter attribute that indicates that the type can be converted using the FilterOptionConverter<Level> class. 
    [TypeConverter(typeof(FilterOptionConverter<Level>))]
    // Inherits from the IFilterOption interface
    public class Level : IFilterOption
    {
        // Uses a short Id as global uniqueness and count of possibilities are both far less important as there is no security risk for levels nor risk of using all 65536 possibilities. 
        public short Id { get; set; }
        public string Name { get; set; } = string.Empty;

        // Overrides the ToString method from the object class to return the JSON representation of the object. 
        public override string ToString()
        {
            return JsonSerializer.Serialize(this);
        }
    }

    // Level class that represents the ExamBoard table
    // TypeConverter attribute that indicates that the type can be converted using the FilterOptionConverter<ExamBoard> class. 
    [TypeConverter(typeof(FilterOptionConverter<ExamBoard>))]
    // Inherits from the IFilterOption interface
    public class ExamBoard : IFilterOption
    {
        // Uses a short Id as global uniqueness and count of possibilities are both far less important as there is no security risk for levels nor risk of using all 65536 possibilities. 
        public short Id { get; set; }
        public string Name { get; set; } = string.Empty;

        // Overrides the ToString method from the object class to return the JSON representation of the object. 
        public override string ToString()
        {
            return JsonSerializer.Serialize(this);
        }
    }

    // Backing interface for the Filter Options. 
    public interface IFilterOption
    {
        public short Id { get; set; }
        public string Name { get; set; }
    }

    // Type converter for filter options that allows for converting from and to the string format of a filter option. 
    public class FilterOptionConverter<T> : TypeConverter where T : IFilterOption, new()
    {
        public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType)
        {
            return sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);
        }

        public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
        {
            /// May need to assign Id also, assuming not for now. 
            return JsonSerializer.Deserialize<T>((string)value);
        }

        public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
        {
            if (value is null)
            {
                return value;
            }

            return JsonSerializer.Serialize(value);
        }
    }
}

```
==== QuestionSearchModel.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CourseworkPastPaperApplication2.Shared
{
    // The question search model used to search through questions in associated queries and requests from the client-side. 
    public struct QuestionSearchModel
    {
        // Hash set of keywords used. 
        // It is a hash set to prevent duplicate keywords. 
        public HashSet<string> KeywordsList { get; set; }
        
        // Boolean flag indicated whether or not to retrieve only questions that match all keywords or to maximise the number of matches instead. 
        public bool All { get; set; }
        
        // All exam boards that the question can be of. 
        public IEnumerable<ExamBoard> ExamBoards { get; set; }

        // All levels that the question can be of. 
        public IEnumerable<Level> ValidLevels { get; set; }
    }
}

```
==== Student.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace CourseworkPastPaperApplication2.Shared;

// Class representing the Student table
// Names of properties indicate the field they represent except from for the collections which are representing any one-to-many/many-to-many links or properties not using the { get; set; } syntax as those are simply used for easier functionality in the class. 
// This class inherits from the User class which defines certain properties such as the Name, Password, and PasswordAsHex (hexadecimal representation of the passwrod). 
public class Student : User
{
    public Student()
    {

    }

    public Student(Guid id, string name, byte[] password) : base(id, name, password)
    {
    }

    public virtual ICollection<PaperResult> PaperResults { get; } = new List<PaperResult>();

    [JsonIgnore]
    public virtual ICollection<Class> CurrentClasses { get; } = new List<Class>();
}

```
==== Teacher.cs
```cs
﻿using CourseworkPastPaperApplication2.Shared;
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.Json.Serialization;

namespace CourseworkPastPaperApplication2.Shared;

// Class representing the Teacher table
// Names of properties indicate the field they represent except from for the collections which are representing any one-to-many/many-to-many links or properties not using the { get; set; } syntax as those are simply used for easier functionality in the class. 
// This class inherits from the User class which defines certain properties such as the Name, Password, and PasswordAsHex (hexadecimal representation of the passwrod). 
public class Teacher : User
{
    public Teacher()
    {
    }

    public Teacher(Guid id, string name, byte[] password) : base(id, name, password)
    {
    }

    [JsonIgnore]
    public virtual ICollection<Class> Classes { get; } = new List<Class>();
}

```
==== User.cs
```cs
﻿using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace CourseworkPastPaperApplication2.Shared
{
    // Abstract base class for the Student and Teacher classes, defining the Name, Password, and PasswordAsHex properties of the class. 
    public abstract class User : DbTable
    {
        public User()
        {

        }

        public User(Guid id, string name, byte[] password)
        {
            Id = id;
            Name = name;
            Password = password;
        }

        [JsonConstructor]
        public User(Guid id, string name, string password)
        {
            Id = id;
            Name = name;
            PasswordAsHex = password;
        }

        public string Name { get; set; } = null!;
        public byte[] Password { get; set; } = null!;

        [JsonIgnore]
        public string PasswordAsHex { get => Encoding.UTF8.GetString(Password); set => Password = Encoding.UTF8.GetBytes(value); }

        // SQL defined function that converts a password as a string to its byte format
        // This can be used in SQL queries. 
        public static byte[] SQLStringToUtf8(string password)
        {
            return Encoding.UTF8.GetBytes(password);
        }
    }
}

```
==== UserWithUnencryptedPassword.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CourseworkPastPaperApplication2.Shared
{
    // This class represents the user login/sign-up details that a user may enter on the client-side and supply to the server-side. 
    public struct UserWithUnencryptedPassword
    {
        public string Name { get; set; }
        public string Password { get; set; }
    }
}
```
=== obj
==== Debug
===== net7.0
====== CourseworkPastPaperApplication2.Shared.AssemblyInfo.cs
```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CourseworkPastPaperApplication2.Shared")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("CourseworkPastPaperApplication2.Shared")]
[assembly: System.Reflection.AssemblyTitleAttribute("CourseworkPastPaperApplication2.Shared")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


```
====== CourseworkPastPaperApplication2.Shared.GlobalUsings.g.cs
```cs
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

```
====== ref
====== refint
==== Release
===== net7.0
====== CourseworkPastPaperApplication2.Shared.AssemblyInfo.cs
```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CourseworkPastPaperApplication2.Shared")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("CourseworkPastPaperApplication2.Shared")]
[assembly: System.Reflection.AssemblyTitleAttribute("CourseworkPastPaperApplication2.Shared")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


```
====== CourseworkPastPaperApplication2.Shared.GlobalUsings.g.cs
```cs
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

```
====== ref
====== refint
=== ResultsTable.cs
```cs
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using CourseworkPastPaperApplication2;

namespace CourseworkPastPaperApplication2.Shared
{
    // Attribute and implemented interface to indicate that this can be serialised. 
    [Serializable]
    // This inherits from the IEnumerable interface which makes an IEnumerable and so able to be natively looped through and manipulated with LINQ queries. 
    // This is a form of polymorphism without the limitations of polymorphism. 
    // However, this also creates an issue in that the default JsonSerializer class will recognise that this is a collection and try to serialise it as such. 
    // I have created two options for countering this:
    // A lightweight but slightly less performant option that is useful for single conversions: the NonEnumerableResultsTable class, more on that by the definition. 
    // The other option is to use the custom JSON serialisation converters implemented below, this requires additional memory and management, however, and only improves on performance by a minute amount and so is not the preferred method used in the codebase despite looking nicer to use. 

    // This class is used to represent the results for an assignment, it contains a string[][] containing all the scores and total marks for each question. 
    // These values could be calculated from the Question[] and Student[], however, this table is designed to be used for quickly rendering the tables and so pre-calculating these values makes the page more responsive. 
    public class ResultsTable : IEnumerable<IEnumerable<string>>, ISerializable, IResultsTable
    {
        // Instantiates a new ResultsTable object with empty values. 
        public ResultsTable()
        {
            Results = Array.Empty<string[]>();
            Questions = Array.Empty<Question>();
            Students = Array.Empty<Student>();
        }

        // Constructor that takes in results, questions, and students. 
        public ResultsTable(string[][] results, Question[] questions, Student[] students)
        {
            Results = results;
            Questions = questions;
            Students = students;
        }

        // Property that represents the string[][]. 
        public string[][] Results { get; set; }
        // Property that represents the Question[]
        public Question[] Questions { get; set; }
        // Property that represents the Student[]
        public Student[] Students { get; set; }

        // Count of rows of the table. 
        // JsonIgnore indicates that this property should not be serialised, this is done since it cannot be assigned to and is calulated from the Question[]. 
        [JsonIgnore]
        public int Rows => Questions.Length + 1;
        
        // Count of columns of the table. 
        // JsonIgnore indicates that this property should not be serialised, this is done since it cannot be assigned to and is calulated from the Student[]. 
        [JsonIgnore]
        public int Columns => Students.Length + 1;

        // Implicit converter between ResultsTable and string[][]. 
        // This operator will convert a table to a 2D string array. 
        public static implicit operator string[][](ResultsTable table)
        {
            // Initialises the array. 
            string[][] arr = new string[table.Rows][];

            for (int i = 0; i < arr.Length; i++)
            {
                arr[i] = new string[table.Columns];
            }

            // Assigns the values of the array with values from the table. 
            for (int i = 0; i < table.Rows; i++)
            {
                for (int j = 0; j < table.Columns; j++)
                {
                    arr[i][j] = table[i, j];
                }
            }

            return arr;
        }

        // Conversion method from the IResultsTable backing interface, simply maps the properties. 
        public static ResultsTable FromIResultsTable(IResultsTable table)
        {
            return new ResultsTable { Questions = table.Questions, Results = table.Results, Students = table.Students };
        }

        // Indexer property, allows the table to be used as such: table[3, 7] to access values in the table, as though it were a 2D array. 
        public string this[int i, int j]
        {
            // Gets a value by pattern matching
            // Top left value is empty as indicated by the (0, 0) case. 
            // Rest of top row are students as indicated by the (0, int studentIndex) case. 
            // studentIndex matches the value of j. 
            // Left-most column are questions as indicated by the (int questionIndex, 0) case. 
            // (_, _) case simply matches anything that does not match any other case and so, of course, by elimination, must be a result. 
            get => (i, j) switch
            {
                (0, 0) => string.Empty,
                (0, int studentIndex) => Students[studentIndex - 1].Name,
                (int questionIndex, 0) => Questions[questionIndex - 1].FileName,
                (_, _) => Results[i - 1][j - 1]
            };

            // Same process as above but assigning instead of returning. 
            set
            {
                switch ((i, j))
                {
                    case (0, 0):
                        break;
                    case (0, int questionIndex):
                        Questions[questionIndex - 1].FileName = value;
                        break;
                    case (int studentIndex, 0):
                        Students[studentIndex - 1].Name = value;
                        break;
                    case (_, _):
                        Results[i - 1][j - 1] = value;
                        break;
                }
            }
        }

        // Representation of this as an IEnumerable
        // Yields each row. 
        public IEnumerator<IEnumerable<string>> GetEnumerator()
        {
            for (int i = 0; i < this.Rows; i++)
            {
                yield return Enumerable.Range(0, this.Columns).Select(j => this[i, j]);
            }
        }

        // Required for the IEnumerable interface, links back to the GetEnumerator method defined above. 
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        // Used for de/serialisation, adds each property to the serialisation info such that it knows what to serialise. 
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            Type resultsType = typeof(ResultsTable);

            resultsType.GetProperties().ForEach(property => info.AddValue(property.Name, property.GetValue(this)));
        }

        // Used for deserialisation, constructs a new instance using serialisation info and a streaming context. 
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        protected ResultsTable(SerializationInfo info, StreamingContext context)
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            Type resultsType = typeof(ResultsTable);

            // Gets all parameters to be used. 
            object?[] parameters = resultsType.GetProperties().Select(property => info.GetValue(property.Name, property.PropertyType)).ToArray();

            // Gets a constructor to call with the parameters given then calls it to instantiate the object. 
            ConstructorInfo? constructorInfo = resultsType.GetConstructor(resultsType.GetProperties().Select(property => property.PropertyType).ToArray());

            if (constructorInfo is null)
            {
                throw new SerializationException($"No constructor was found for given properties on {nameof(ResultsTable)}");
            }

            constructorInfo.Invoke(this, parameters);
        }
    }

    // Backing interface for the ResultsTable classes. 
    public interface IResultsTable
    {
        Question[] Questions { get; set; }
        Student[] Students { get; set; }
        string[][] Results { get; set; }

        [JsonIgnore]
        public string this[int i, int j] { get; set; }
    }

    // Used for serialisation and deserialisation process. 
    // Can be implicitly converter to and from with the ResultsTable class, allowing for syntax such as `ResultsTable table = Deserialise<NonEnumerableResultsTable>()`, for example (this is not actual code, there is no Deserialise method with that signature in this codebase). 
    public class NonEnumerableResultsTable : IResultsTable
    {
        // Private instance of ResultsTable to store all the data. 
        private ResultsTable table = new ResultsTable();

        // All properties defined here have accessor methods that simply link back to the ResultsTable class. 
        public string this[int i, int j] { get => table[i, j] ; set => table[i, j] = value; }

        public Student[] Students { get => table.Students; set => table.Students = value; }
        public Question[] Questions
        {
            get => table.Questions;
            set => table.Questions = value;
        }

        public string[][] Results { get => table.Results; set => table.Results = value; }

        // Implicit conversion method between NonEnumerableResultsTable and ResultsTable. 
        public static implicit operator ResultsTable(NonEnumerableResultsTable nonEnumerableResultsTable)
        {
            // Returns the table field. 
            return nonEnumerableResultsTable.table;
        }

        // Implicit conversion method between ResultsTable and NonEnumerableResultsTable. 
        public static implicit operator NonEnumerableResultsTable(ResultsTable resultsTable)
        {
            // Instantiates a new NonEnumerableResultsTable with the table field set to the table being converted. 
            var nonEnumerableTable = new NonEnumerableResultsTable
            {
                table = resultsTable
            };

            return nonEnumerableTable;
        }
    }

    // ResultsTableInitialisationComponents is a class containing all parts needed to build a new ResultsTable, just used to store and transport data. 
    public class ResultsTableInitialisationComponents
    {
        public Student[] Students { get; set; } = null!;
        public Guid Id { get; set; }
        public string Name { get; set; } = null!;
        public Question[] Questions { get; set; } = null!;
    }

    // Custom ResultsTable converter for JSON. 
    public class ResultsTableJsonConverter : JsonConverter<ResultsTable>
    {   
        // Dictionary matching property names to their information. 
        private static readonly Dictionary<string, PropertyInfo> propertyNameToInfoDictionary;

        // Initialises the propertyNameToInfoDictionary with the types of ResultsTable. 
        static ResultsTableJsonConverter()
        {
            propertyNameToInfoDictionary = typeof(ResultsTable)
                .GetProperties()
                .Where(property => !property.GetIndexParameters().Any())
                .Where(property => !Attribute.IsDefined(property, typeof(JsonIgnoreAttribute)))
                .ToDictionary(property => property.Name);
        }

        // Reads in a new ResultsTable instance from a Utf8JsonReader instance and options. 
        /// Consider stopping Question from fully serialising to save on memory and improve speed. 
        public override ResultsTable? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            // Initialises a blank object. 
            ResultsTable tableToBeCreated = new ResultsTable();

            // Reads until file empty. 
            while (reader.Read())
            {
                // Checks if read a property name. 
                if (reader.TokenType == JsonTokenType.PropertyName)
                {
                    // If read, gets the corresponding value from the dictionary and deserialises it from JSON then sets it as a property on tableToBeCreated. 
                    if (propertyNameToInfoDictionary.TryGetValue(reader.GetString() ?? string.Empty, out PropertyInfo? info))
                    {
                        reader.Read();
                        
                        object? value = JsonSerializer.Deserialize(ref reader, info.PropertyType, options);

                        info.SetValue(tableToBeCreated, value);
                    }

                    continue;
                }

                // If the object's JSON form has ended, stops searching. 
                if (reader.TokenType == JsonTokenType.EndObject)
                {
                    break; 
                }
            }

            return tableToBeCreated;
        }

        // Writes the JSON format of a ResultsTable to a Utf8JsonWriter. 
        public override void Write(Utf8JsonWriter writer, ResultsTable value, JsonSerializerOptions options)
        {
            // Starts the JSON string. 
            writer.WriteStartObject();

            // Loops through properties and serialises each one then writes it. 
            foreach (PropertyInfo propertyInfo in propertyNameToInfoDictionary.Values)
            {
                object property = propertyInfo.GetValue(value) ?? throw new SerializationException($"Could not serialize in {propertyInfo} for {value}");

                writer.WritePropertyName(propertyInfo.Name);

                var newOptions = new JsonSerializerOptions(options);

                newOptions.Converters.Add(new IgnorePropertyIfConverter<Question>(property => property.Name == "Data"));

                JsonSerializer.Serialize(writer, property, propertyInfo.PropertyType, newOptions);
            }

            writer.WriteEndObject();
        }
    }

    // Custom JSON converter to ignore a property on write if a predicate is matched. 
    public class IgnorePropertyIfConverter<T> : JsonConverter<T>
    {
        // The specified prediate. 
        private readonly Func<PropertyInfo, bool> propertyPredicate;

        // Constructor to initialise with a predicate. 
        public IgnorePropertyIfConverter(Func<PropertyInfo, bool> propertyPredicate)
        {
            this.propertyPredicate = propertyPredicate;
        }

        // Since this only deals with Writing, uses the default reading operation. 
        public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            return JsonSerializer.Deserialize<T>(ref reader, options) ?? throw new SerializationException("Could not serialize");
        }

        // Writes the JSON format of the object being serialised to a Utf8JsonWriter. 
        public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
        {
            // Starts the JSON string. 
            writer.WriteStartObject();

            // Loops through properties that match the predicate and serialises each one then writes it. 
            foreach (var property in typeof(T).GetProperties().Where(p => propertyPredicate(p)))
            {
                writer.WritePropertyName(property.Name);
                JsonSerializer.Serialize(writer, property.GetValue(value), options);
            }

            writer.WriteEndObject();
        }
    }


}

```
